<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有疑说</title>
  
  <subtitle>博学、慎思、明辨、笃行</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://www.cyningsun.com/"/>
  <updated>2022-11-11T15:35:56.461Z</updated>
  <id>https://www.cyningsun.com/</id>
  
  <author>
    <name>cyningsun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>译｜Dependency Management</title>
    <link href="https://www.cyningsun.com/06-08-2022/dependency-management-cn.html"/>
    <id>https://www.cyningsun.com/06-08-2022/dependency-management-cn.html</id>
    <published>2022-06-07T16:00:00.000Z</published>
    <updated>2022-11-11T15:35:56.461Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>译者序</strong></p><p>本文为 Bazel 依赖管理的文章，介绍了大规模下依赖关系的复杂情况及其应对策略。从本文可以学到什么？</p><ol><li>了解构建系统依赖管理的基本情况</li><li>理解 Golang 内置的构建工具和后续的发展方向</li><li>版本如何影响公司内部基础架构升级</li></ol></blockquote><p>在浏览前面的页面时，有一个主题反复提及：管理自己的代码相当简单，但管理其依赖关系则困难得多。存在各种各样的依赖关系：有时依赖于某个任务（如“将版本标记为完成之前推送文档”）；有时依赖于某个制品（如“需要最新版本计算机视觉库才能构建代码）；有时，内部依赖于代码库的另一部分，并且有时外部依赖于其他团队（无论是组织内还是第三方）的代码或数据。但无论如何，“欲此先彼”的观念在构建系统的设计中反复出现，管理依赖关系或许是构建系统最基本的工作</p><h3 id="应对模块和依赖关系"><a href="#应对模块和依赖关系" class="headerlink" title="应对模块和依赖关系"></a>应对模块和依赖关系</h3><p>使用基于制品的构建系统（如Bazel）的项目被分解为一组模块，模块通过 <code>BUILD</code> 文件表示彼此之间的依赖关系。正确组织模块和依赖关系会对构建系统的性能以及维护工作量产生巨大影响。</p><h3 id="使用精细模块和-1：1：1-规则"><a href="#使用精细模块和-1：1：1-规则" class="headerlink" title="使用精细模块和 1：1：1 规则"></a>使用精细模块和 1：1：1 规则</h3><p>在组织基于工件的构建时，第一个问题是确定单个模块应该包含多少功能。在 Bazel 中，模块由描述说明可构建单元（如 java_library 或 go_binary）的目标表示。 一种极端情况下，整个项目可以包含在一个模块中，方法是将一个 BUILD 文件放在根目录下，并以递归方式将该项目的所有源文件合并在一起。另外一种极端情况下，几乎每个源文件都可以放到自己的模块中，实质上要求每个文件在 BUILD 文件中列出它所依赖的其他所有文件</p><p>大多数项目都处于极端情况之间，选择涉及性能和可维护性之间的权衡。整个项目使用一个模块意味着，除了从外部添加依赖项之外，再不需要更改 BUILD 文件，但构建系统必须始终一次性构建整个项目。这意味着它无法将各部分并行或分布式构建，也无法缓存已构建的部分。每个文件一个模块则相反：构建系统在构建的缓存和调度步骤方面具有最大的灵活性，但每当更改文件引用文件时，工程师需要花费更多精力来维护依赖项列表。</p><p>尽管确切的粒度因语言而异（甚至在语言内也是如此），但相比基于任务的构建系统中编写的典型的模块，Google 倾向于使用小得多的模块。Google 的典型生产二进制文件通常依赖于数万个目标，即使是中等规模的团队也可以在其代码库中拥有数百个目标。对于具有强大内置的打包概念的语言（如 Java），每个目录通常包含一个软件包、目标和 BUILD 文件（Pants，另一个基于 Bazel 的构建系统，称之为 1:1:1 规则）。打包概念较弱的语言，每个 BUILD 文件通常会定义多个目标。</p><p>较小的构建目标的好处在大规模时开始显现出来，因为它们可以加快分布式构建的速度，减少重建目标的频率。 测试入场后，优势变得更加引人注目，因为更细粒度的目标意味着构建系统可以更智能地运行可能受给定更改影响的有限测试子集。由于 Google 认为使用较小的目标具有系统方面的优势，因此我们通过投资自动管理 BUILD 文件的工具，以避免给开发人员带来负担，从而在减轻不利影响方面迈出了一大步。</p><p>其中一些工具，如 <code>buildizer</code> 和 <code>buildozer</code>，可以放在 <a href="https://github.com/bazelbuild/buildtools">buildtools</a> 目录中与 Bazel 一起使用</p><h3 id="最小化模块可见性"><a href="#最小化模块可见性" class="headerlink" title="最小化模块可见性"></a>最小化模块可见性</h3><p>Bazel 和其他构建系统允许每个目标指定可见性：一种指定哪些目标可以依赖于它的属性。目标可以是公共的，此时，工作区中的任何其他目标都可以引用它；私有的，此时，只允许同一个 BUILD 文件中引用它；或仅对明确定义的其他目标列表可见。可见性本质上与依赖相反：如果目标 A 想要依赖目标 B，则目标 B 必须使其自身对目标 A 可见。与大多数编程语言一样，通常最好尽可能降低可见性。一般来说，仅当目标代表 Google 的任何团队都可以广泛使用的库时，Google 团队才会公开。要求在使用他们代码之前与他们协调的团队，会维护一份允许的客户目标列表，作为其目标的可见范围。每个团队内部实现的目标将可见性仅限于团队拥有的目录，大多数BUILD 文件只有一个非私有的目标。</p><h3 id="管理依赖项"><a href="#管理依赖项" class="headerlink" title="管理依赖项"></a>管理依赖项</h3><p>模块需要能够相互引用。将代码库拆分成精细的模块的缺点是，需要管理模块之间的依赖关系（尽管工具可以帮助自动执行）。表达依赖关系通常最终成为 BUILD 文件中的大部分内容。</p><h4 id="内部依赖项"><a href="#内部依赖项" class="headerlink" title="内部依赖项"></a>内部依赖项</h4><p>在分解为精细模块的大型项目中，大多数依赖项可能是内部依赖项；即，在同一源代码库中定义和构建的另一个目标。内部依赖项与外部依赖项的不同之处在于，它们是从源代码构建的，而不是在运行构建时以预构建制品下载的。这也意味着内部依赖项没有“版本”概念，目标及其所有内部依赖项始终在存储库中的同一提交/修订时构建。关于内部依赖项，如何处理可传递依赖项（图 1）是一个应谨慎处理的问题。假设目标 A 依赖于目标 B，而目标 B 依赖于通用库目标 C。目标 A 是否能够使用目标 C 中定义的类？</p><p><img src="/images/dependency-management-cn/transitive-dependencies.png" alt="transitive-dependencies.png"><br>图 1. 可传递依赖项</p><p>就底层工具而言，这么做没有任何问题； B 和 C 都会在构建时链接到目标 A，因此 C 中定义的任何符号都是已知的。Bazel 多年来一直允许这种情况出现，但随着 Google 不断发展，我们看到了一些问题。假设 B 已重构，使其不再需要依赖于 C。如果 B 对 C 的依赖被移除，那么通过 B 的依赖关系使用 C 的 A 以及其他所有目标都会破坏。实际上，目标的依赖项会成为其公共合约的一部分，永远无法安全更改。这意味着，依赖关系会随着时间的推移而积累，Google 的构建速度会开始变慢。</p><p>Google 最终在 Bazel 中引入了“严格可传递依赖关系模式”，从而解决了此问题。在此模式下，Bazel 会检测目标是否试图直接引用符号，而不依赖于它；如果是的话，则失败，并显示错误以及一条可用于自动插入依赖项的 shell 命令。在 Google 的整个代码库中推广这一变化，并重构数百万个构建目标，以明确列出它们的依赖项，该项目花费了多年的努力，但非常值得。由于目标中不必要依赖项减少，现在构建要快得多。而且，工程师有权删除他们不需要的依赖项，而不用担心破坏依赖它们的目标。</p><p>与往常一样，强制执行严格的可传递依赖关系需要做出权衡。因为现在经常使用的库需要在许多位置显式列出，而不是被意外地拉取，使得构建文件更详细；而工程师需要花费更多精力在 BUILD 文件中添加依赖项。此后，我们开发了相关工具，可在不进行任何开发者干预的情况下，自动检测许多缺失的依赖项并将其添加到 BUILD 文件，从而减少此类繁重工作。但即使没有此类工具，我们也发现，在代码库扩大规模的情况下这样做非常值得：显式地将依赖项添加到构建文件是一次性的成本，但只要构建目标存在，处理隐式可传递依赖关系就会导致持续的问题。默认情况下，Bazel 会在 Java 代码中强制执行<a href="https://blog.bazel.build/2017/06/28/sjd-unused_deps.html">严格可传递依赖关系</a></p><h4 id="外部依赖项"><a href="#外部依赖项" class="headerlink" title="外部依赖项"></a>外部依赖项</h4><p>如果依赖项不是内部依赖项，它一定是外部依赖项。外部依赖项是指在构建系统之外构建和存储的制品。系统直接从制品库（通常通过互联网访问）导入依赖项，并按原样使用，而不是从源代码构建。外部依赖项与内部依赖项之间的最大差异之一是，外部依赖项有版本，并且版本独立于项目的源代码。</p><h4 id="自动-vs-手动-管理依赖项"><a href="#自动-vs-手动-管理依赖项" class="headerlink" title="自动 vs 手动 管理依赖项"></a>自动 vs 手动 管理依赖项</h4><p>构建系统可以手动或自动管理外部依赖项的版本。手动管理时，构建文件会明确列出要从制品库下载的版本，通常使用 1.1.4 等<a href="https://semver.org/">语义版本字符串</a>。自动管理时，源文件会指定可接受版本的范围，而构建系统始终会下载最新版本。例如，Gradle 将依赖项版本声明为“1.+”，以指定依赖项的主版本或补丁版本可以接受，前提是主版本为 1。</p><p>对小型项目来说，自动管理依赖项很方便，但它们通常是非一般规模的项目或由多个工程师处理的项目的灾难。自动管理依赖项的问题在于，无法控制版本更新。无法保证外部一方不会进行中断性的更新（即使他们声称使用语义化版本），因此，某一天工作过的构建版本可能会在第二天就被破坏，并且没有简单的方法来检测更改的内容或将其回滚到工作状态。即使构建不会中断，也可能出现无法跟踪的细微的行为或性能变化。</p><p>相比之下，手动管理的依赖项需要更新到源代码控制系统，可以轻松地找到和回滚这些依赖项，并且可以签出旧版代码库以使用旧版依赖项构建。Bazel 要求手动指定所有依赖项的版本。即使在中等规模下，手动版本管理的开销也非常值得，因为这样可以获得稳定性。</p><h4 id="单一版本规则"><a href="#单一版本规则" class="headerlink" title="单一版本规则"></a>单一版本规则</h4><p>库的不同版本通常由不同的制品表示，因此理论上讲，没有理由不能在构建系统中以不同的名称声明同一外部依赖项的不同版本。这样，每个目标就都可以选择要使用的依赖项版本。这会导致实践中遇到许多问题，因此 Google 对代码库中的所有第三方依赖项强制执行严格的<a href="https://opensource.google/docs/thirdparty/oneversion/">单一版本规则</a>。</p><p>允许多个版本的最大问题是钻石依赖性问题。假设目标 A 依赖于目标 B 以及外部库的 v1。如果后续重构目标 B，添加对同一外部库的 v2 的依赖项，则目标 A 会中断，因为它现在隐式依赖于同一库的两个不同版本。实际上，添加新的从目标到具有多个版本的任何第三方库的依赖关系的做法，从来都不是安全的，因为该目标的任何用户都可能已经依赖于不同的版本。遵循单一版本规则可以避免该冲突。如果目标添加对第三方库的依赖关系，现存所有依赖关系已经采用相同的版本，因此可以和谐共存。</p><h4 id="可传递外部依赖关系"><a href="#可传递外部依赖关系" class="headerlink" title="可传递外部依赖关系"></a>可传递外部依赖关系</h4><p>处理外部依赖项的可传递依赖关系特别困难。许多制品库（如：Maven、Central）允许制品指定仓库中特定版本的其他制品的依赖关系。默认情况下，Maven 或 Gradle 等构建工具通常以递归方式下载每个可传递依赖关系，意味着在项目中添加单个依赖项可能会导致总共下载数十个制品。</p><p>这样非常方便：添加一个新库的依赖项时，必须跟踪该库的每个传递依赖关系，并手动添加所有依赖关系，是一件非常痛苦的事。但也存在一个巨大的缺点：由于不同的库可以依赖于同一第三方库的不同版本，因此必然会违反单一版本规则，导致钻石依赖关系问题。如果目标依赖的两个外部库使用相同依赖项的不同版本，则无法确定具体会获取哪个库。也意味着，如果新版本开始拉取它的某些依赖项的冲突版本，则可能会导致整个代码库中看似不相关的故障。</p><p>因此，Bazel 不会自动下载传递依赖项。然而，并没有万能的办法，Bazel 的替代方案是，使用全局文件列出代码库的每个外部依赖项以及用于整个代码库的相应依赖项的显式版本。幸运的是，Bazel 提供的工具能够自动生成这样的文件，其中包含一组 Maven 制品的可传递依赖关系。可以运行该工具一次，以生成项目的初始 WORKSPACE 文件；然后，可以手动更新该文件，以调整每个依赖项的版本。</p><p>再次强调，这是一种方便性和扩展性之间的选择。小型项目可能本身无需担心管理可传递依赖关系，并且可能无需使用自动可传递依赖关系。随着组织和代码库的增长，冲突和意外结果变得越来越频繁，此策略变得越来越没有吸引力。在较大规模时，手动管理依赖项的成本远低于处理自动管理依赖项引起的问题的成本。</p><h4 id="使用外部依赖关系缓存构建结果"><a href="#使用外部依赖关系缓存构建结果" class="headerlink" title="使用外部依赖关系缓存构建结果"></a>使用外部依赖关系缓存构建结果</h4><p>外部依赖项通常由发布稳定版本的库（可能未提供源代码）的第三方提供。一些组织还会选择将自己的一些代码作为制品提供，以便其他代码可以作为第三方（而非内部依赖项）依赖它们。如果制品的构建速度很慢但下载速度很快，理论上，可加快构建速度。</p><p>但是，这种方法也带来了很多开销和复杂性：需要负责构建每个制品并将其上传到制品库，并且客户需要确保自身保持最新版本。调试也变得更加困难，因为系统的不同部分是从存储库中的不同点构建的，并且不再有源代码库树的一致视图。</p><p>如前所述，如需解决制品构建时间较长的问题，一种更好的方式是使用支持远程缓存的构建系统。此类构建系统会将每个构建生成的制品保存到工程师共享的位置，因此如果开发者依赖其他人最近构建的制品，构建系统会自动下载无需构建。这样做提供了直接依赖于工件做法的所有性能优势，同时仍然确保构建与从同一源构建一样。这是 Google 内部使用的策略，Bazel 支持配置使用远程缓存。</p><h4 id="外部依赖的安全性和可靠性"><a href="#外部依赖的安全性和可靠性" class="headerlink" title="外部依赖的安全性和可靠性"></a>外部依赖的安全性和可靠性</h4><p>依赖于第三方来源的制品本身存在风险。如果第三方源代码（例如：制品库）发生故障，则会有可用性风险，因为如果无法下载外部依赖项，整个构建可能会停止。还有一种安全风险：如果第三方系统遭到攻击者入侵，攻击者可以将引用的制品替换为他们自己的设计之一，从而将任意代码注入到您的 build 中。将依赖的任何制品镜像到受控的服务器，并阻止构建系统访问 Maven Central 等第三方制品库，可以解决这两个问题。需要权衡的是，镜像需要精力和资源维护，因此，是否使用它们通常取决于项目的规模。通过在源存储库中指定每个第三方制品的哈希值，也可以完全防止安全问题，而开销很小，如果制品被篡改，则会导致构建失败。另一种完全回避问题的替代方法是拷贝（vendor）项目的依赖项。当项目拷贝（vendor）其依赖项时，它会将这些依赖项和项目的源代码（源代码或二进制文件）签入源代码控制系统。这实际上意味着，项目的所有外部依赖项都会转换为内部依赖项。Google 在内部使用此方法，将整个 Google 中引用的每个第三方库签入 Google 源代码树根目录下的 third_party 目录。但是，这仅在 Google 有效，因为 Google 的源代码控制系统是为了处理超大单一代码库而专门构建的，因此拷贝可能不适合所有组织。</p><p><em>原文：</em> <a href="https://bazel.build/basics/dependencies">Dependency Management</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/06-08-2022/dependency-management-cn.html">https://www.cyningsun.com/06-08-2022/dependency-management-cn.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;译者序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文为 Bazel 依赖管理的文章，介绍了大规模下依赖关系的复杂情况及其应对策略。从本文可以学到什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;了解构建系统依赖管理的基本情况&lt;/li&gt;
&lt;li&gt;理解 Gol
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何快速定位现网 BUG</title>
    <link href="https://www.cyningsun.com/09-13-2021/how-to-locate-bug-in-production-env.html"/>
    <id>https://www.cyningsun.com/09-13-2021/how-to-locate-bug-in-production-env.html</id>
    <published>2021-09-12T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/how-to-locate-bug-in-production-env/bugfix.jpg" alt="bugfix.jpg"></p><p>“幸福的家庭都是相似的，不幸的家庭却各有各的不幸”，托尔斯泰的名言。在 BUG 定位这件事情上，其实也有类似的现象：”菜鸟们的紧张无措都是相似的，老鸟们的方法却各有各的不同”。</p><p>年年过大促，年年定位现网故障。果不其然，今年 9.9 大促再次踩坑。看到组内的新手们排查问题的手足无措，也就有了这篇文档。本文的目的不在于穷举所有排查问题的手段，而在于帮助新手们避雷。</p><h3 id="蜻蜓点水"><a href="#蜻蜓点水" class="headerlink" title="蜻蜓点水"></a>蜻蜓点水</h3><p>当遇到无法轻易复现，并且缺少有用的日志辅助缺陷排查的时候，新手们的一般会选择去看代码。然而，最关键的点来了，他们并不是在真正看代码，他们只是印证自己”脑海中记忆的代码” 跟代码库里的是一致的。最常见的一个结果，就是得到一个 “代码是这样的呀、没有问题呀” 的结论。看代码过程是轻浮的，是跳跃的。</p><p>然而，计算机执行的并不是你脑海中的代码，而是实实在在的代码。计算机是严谨的、会一丝不苟的，从调用入口开始，一行不漏的逐行执行完毕，然后返回结果。任何细微的差异都有可能执行的是路径完全不同，而 BUG 就是因为走了跟预期不一样的执行路径。</p><p>看代码需要一行一行的看，一层层调用的展开。无论是自己编写的代码，还是开源仓库的代码，还是服务框架的代码，任何一行代码都不应该被跳过。</p><p>脚踏实地，而不是蜻蜓点水。</p><h3 id="轻视数据"><a href="#轻视数据" class="headerlink" title="轻视数据"></a>轻视数据</h3><p>大型复杂的系统产生了繁多的数据。不同的团队成员看到数据（事实）之后，会加入自己对数据的判断（观点），呈现出二次加工之后的数据。最终可能得到是一份夹杂了观点和事实的数据。</p><blockquote><p>当你听到蹄子声响时，你可以说听到了马蹄声，但实际上也可能是斑马蹄的声音，虽然概率很低。</p></blockquote><p>同时，就会出现以下类型的数据误用：</p><ul><li>不对数据数据进行汇总、分析，基于片面的数据进行假设</li><li>基于不可靠的数据，导致错误的假设</li></ul><p>基于错误的、片面的数据，进行假设，最终大概率是徒劳而无功。</p><p>靠谱的使用数据的方式，应当是团队成员把相关的数据汇聚，根据业务架构形成 “马赛克调查墙”，基于 “马赛克调查墙” 确定方向，再进行假设。</p><h3 id="轻视逻辑"><a href="#轻视逻辑" class="headerlink" title="轻视逻辑"></a>轻视逻辑</h3><p>很多很多人一上来就开始猜答案，基于他们认定的答案来提问，这是特别坏的一个习惯，因为这样找问题几乎就只能凭运气了。</p><p>“分治”（Divide &amp; Conquer）是一种非常通用的解决方案。在一个多层系统中，整套系统需要多层组件共同协作完成。最好的办法通常是从系统的一端开始，逐个检查每一个组件，直到系统最底层。这样的策略非常适用于数据处理流水线。在大型系统中，逐个检查可能太慢了，可以采用对分法（bisection）将系统分为两部分，确认问题所在再重复进行。逐项排除、层层递进，才能系统的剥离出真相。</p><p>还有一个常见的逻辑误区“相关性 = 因果性”。然而，相关性并不代表因果性。比如:</p><blockquote><p>统计表明，游泳死亡人数越高，冰糕卖得越多，也就是游泳死亡人数和冰糕售出量之间呈正相关性，我们可以由此得出结论说吃冰糕就会增加游泳死亡风险吗？显然不可以！这两个事件显然都仅仅是夏天到了气温升高了所导致的，吃不吃冰糕跟游泳死亡风险根本没有任何因果关系。</p></blockquote><p>同理，跟 BUG 相关的异常数据，不代表数据的操作导致了 BUG。为了论证因果关系，需要更加严密的实证来说明。按照相关理论复现所有 BUG 表现的特性，且只表现这些特征。</p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/09-13-2021/how-to-locate-bug-in-production-env.html">https://www.cyningsun.com/09-13-2021/how-to-locate-bug-in-production-env.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/how-to-locate-bug-in-production-env/bugfix.jpg&quot; alt=&quot;bugfix.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;“幸福的家庭都是相似的，不幸的家庭却各有各的不幸”，托尔斯泰的名言。在 BUG 定位这件事情
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>译｜There Are No Reference Types in Go</title>
    <link href="https://www.cyningsun.com/08-23-2021/there-are-no-reference-types-in-go-cn.html"/>
    <id>https://www.cyningsun.com/08-23-2021/there-are-no-reference-types-in-go-cn.html</id>
    <published>2021-08-22T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.289Z</updated>
    
    <content type="html"><![CDATA[<p>有一天，我用谷歌搜索一个 Go 问题，谷歌将我引导到 <a href="https://golang.org/doc/faq">Go FAQ</a> 页面。问题解决后，我阅读了整个 FAQ。</p><p>这是一次很棒的阅读，我从文章中学到了很多。但我注意到一个问题， <a href="https://golang.org/doc/faq#references">为什么数组是值,而 map、slice 和 channel 是引用</a>？答复如下：</p><blockquote><p>此话题历史久远。在早期，map 和 channel 都是语法指针，不能声明和使用非指针实例。此外，我们在竭尽全力探索数组如何工作。最终，我们认为指针和值的严格分离使语言更难使用。将这些类型更改为对关联的共享数据结构的引用，就解决了这些问题。改变给语言增加了一些令人遗憾的复杂性，但却对可用性产生了很大的影响：Go 一经推出，就成为了一种更高效、更舒服的语言。</p></blockquote><p>令我惊讶的是，Go 官方文档仍在使用<a href="https://github.com/golang/go/commit/b34f0551387fcf043d65cd7d96a0214956578f94">“引用类型”的概念</a>，因为自 <a href="https://github.com/golang/go/commit/b34f0551387fcf043d65cd7d96a0214956578f94">2013 年 4 月 3 日以来，“引用类型”的概念已从 Go 规范中完全删除</a>。现在 Go 规范中有 10 个“引用”词，没有一个代表“引用类型”的概念。</p><p>另一个惊喜是这句话：</p><blockquote><p>…指针和值的严格分离使该语言更难使用。…</p></blockquote><p>此答复将指针和值视为两个不兼容的概念。但是，Go 规范将指针视为特殊值，指针被称为“指针值”。值只是类型的实例。显然，Go 规范中“指针”一词的定义很好。我认为如果使用“指针值和非指针值”会更好。</p><p>所以，我认为此答复给 <a href="https://www.reddit.com/r/golang/comments/4vg7ht/why_are_there_so_many_different_ways_to_pass_by/">Go 社区带来了很多困惑</a>。它与当前 Go 规范冲突，并且打破了概念的一致性。</p><p>谈回第一个惊喜，我认为称呼  map/slice/channel 值为引用值完全没有必要。不仅因为 “reference” 这个词在编程世界中被滥用了，还因为 map/slice/channel 值只是普通的正常值</p><p>以下是 map/slice/channel 类型的内部声明：</p><table><thead><tr><th>Type Family</th><th>Type Declaration</th></tr></thead><tbody><tr><td>map</td><td>struct {<br/> m *internalHashtable <br/>}</td></tr><tr><td>channel</td><td>struct {<br/>  c *internalChannel <br/>}</td></tr><tr><td>slice</td><td>struct {<br/> array *internalArray <br/> len   int <br/> cap   int<br/> }</td></tr></tbody></table><p>请注意，上面的声明可能不完全与官方或非官方的 Go 实现中的声明相同。Go 实现可以直接使用指针表示 map 和 channel 的值，但 Go 规范/编译器永远不会将它们视为指针。因此，你可以放心的将 map/slice/channel 类型视为上面声明的指针包装类型，而不会有任何问题。</p><p>从上面的声明，很容易得出结论：map/slice/channel 只是包含一个非导出指针字段的结构类型。将它们称为引用类型是完全没有必要的。</p><p>Map 和 slice 类型与一般结构类型确实有一个区别。与一般结构类型不同，对于 map 或 slice 类型 T，T{}  不是 T 的零值。但这不是将 map 或 slice 类型拆分为新的引用类型类别的好理由。</p><p>通过理解 Go 的以下两个规则：</p><ul><li>map/slice/channel 值只是普通的指针包装结构的值</li><li>所有赋值，包括参数传递等，都是浅值复制（指针指向的值不会被复制）</li></ul><p>Gopher 应该清楚地理解赋值中的 dest 和 source  map/slice/channel 值将共享被包装的指针所指向的同一底层数据。</p><p>概念是用来帮助程序员理解语言的机制，而不是混淆他们。值、指针值和非指针值的概念足以让 Gopher 理解 Go。</p><p>我希望 Go 文档不会破坏概念定义的一致性。</p><p><em>原文：</em><a href="https://www.tapirgames.com/blog/golang-has-no-reference-values">https://www.tapirgames.com/blog/golang-has-no-reference-values</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/08-23-2021/there-are-no-reference-types-in-go-cn.html">https://www.cyningsun.com/08-23-2021/there-are-no-reference-types-in-go-cn.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有一天，我用谷歌搜索一个 Go 问题，谷歌将我引导到 &lt;a href=&quot;https://golang.org/doc/faq&quot;&gt;Go FAQ&lt;/a&gt; 页面。问题解决后，我阅读了整个 FAQ。&lt;/p&gt;
&lt;p&gt;这是一次很棒的阅读，我从文章中学到了很多。但我注意到一个问题， &lt;a
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Pointer" scheme="https://www.cyningsun.com/tag/Pointer/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言没有引用类型，指针也与众不同</title>
    <link href="https://www.cyningsun.com/08-16-2021/go-has-no-reference-and-safe-pointer.html"/>
    <id>https://www.cyningsun.com/08-16-2021/go-has-no-reference-and-safe-pointer.html</id>
    <published>2021-08-15T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.289Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象编程强调数据和操作绑定，方法是有状态的，本身可能会修改数据。因此编程时确定方法是否会修改原始数据尤其关键。多数从其他语言转到 Go 语言的开发者，都会首先了解 Go 语言传递参数的时候到底是 “传值” 还是 “传引用”。如果第一门开发语言是 C 语言或者 C++ 的开发者，还会区分下什么时候 “传指针”。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="什么是内存？"><a href="#什么是内存？" class="headerlink" title="什么是内存？"></a>什么是内存？</h4><p>可以把内存想想为一系列单元格，一个个排列成一行，每个单元格都有一个唯一的编号。编号顺序递增，代表内存的位置，也即是内存地址。</p><p><img src="/images/go-has-no-reference-and-safe-pointer/pointer-memory.png" alt="pointer-memory.png"></p><p>每个单元格都可以存放一个值，可以通过编号读取和替换单元格内的先前写入的值。</p><h4 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a>什么是变量？</h4><p>糟糕的是，如果直接使用编号编程，就需要开发者自己管理内存，也难以和其他程序同时运行，极大的增加了编写大型程序的难度。</p><p>为了解决这个问题，就需要引入“变量”的概念。变量只是编号的假名、标签或昵称。</p><p><img src="/images/go-has-no-reference-and-safe-pointer/pointer-memory-multiply.png" alt="pointer-memory-multiply.png"></p><pre><code class="hljs go"><span class="hljs-keyword">var</span> a = <span class="hljs-number">6</span><span class="hljs-keyword">var</span> b = a * <span class="hljs-number">3</span></code></pre><h4 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h4><p>而指针的值是另一个变量的编号。指针指向变量的内存地址，就像变量代表值的内存地址一样。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;        a := <span class="hljs-number">200</span>        b := &amp;a        *b++        fmt.Println(a)&#125;</code></pre><p><img src="/images/go-has-no-reference-and-safe-pointer/pointer-memory-variable.png" alt="pointer-memory-variable.png"></p><h4 id="什么是引用？"><a href="#什么是引用？" class="headerlink" title="什么是引用？"></a>什么是引用？</h4><p>在 C++ 语言中，为现有变量声明别名，称为引用变量。如代码所示，a、b、c 三个变量均共享同一内存地址</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;        <span class="hljs-keyword">int</span> &amp;b = a;        <span class="hljs-keyword">int</span> &amp;c = b;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p %p %p\n&quot;</span>, &amp;a, &amp;b, &amp;c); <span class="hljs-comment">// 0x7ffe114f0b14 0x7ffe114f0b14 0x7ffe114f0b14</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="Go-语言没有引用类型"><a href="#Go-语言没有引用类型" class="headerlink" title="Go 语言没有引用类型"></a>Go 语言没有引用类型</h3><p>Go 程序可以创建指向统一内存地址的变量，但无法创建共享相同内存地址的两个变量。如代码所示，b 和 c 具有相同的值（a的地址）但是，b 和 c 的内存地址是唯一的。更新 b 的内容对 c 没有影响。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span>        <span class="hljs-keyword">var</span> b, c = &amp;a, &amp;a        fmt.Println(b, c)   <span class="hljs-comment">// 0x1040a124 0x1040a124</span>        fmt.Println(&amp;b, &amp;c) <span class="hljs-comment">// 0x1040c108 0x1040c110</span>&#125;</code></pre><p><a href="https://github.com/golang/go/commit/b34f0551387fcf043d65cd7d96a0214956578f94">2013年4月3日，“引用类型”的概念已从 Go 规范中完全删除</a>,现在 Go 规范中的“引用”，没有一个代表“引用类型”的概念。</p><h3 id="指针是类型吗？"><a href="#指针是类型吗？" class="headerlink" title="指针是类型吗？"></a>指针是类型吗？</h3><p>指针是类型吗？这个问题可能在 C 或 C++ 中会有比较大的分歧，但是在 Go 语言中十分明确，毫无疑问：<a href="https://golang.org/ref/spec#Pointer_types">是的</a>。</p><blockquote><p>A pointer type denotes the set of all pointers to variables of a given type, called the base type of the pointer. The value of an uninitialized pointer is nil.</p></blockquote><p>既然有类型，就有类型的实例：值，类型和值是截然不同的两个概念。显然，在 Go 语言中，当谈到指针时，包含 “指针类型” 和 “指针值”。</p><p>同时，为了避免指针引入的风险， Go 语言对指针做了不少的约束，如下：</p><ol><li>指针值不支持数学运算</li></ol><pre><code class="hljs go"><span class="hljs-keyword">var</span> p *<span class="hljs-keyword">int</span>p++</code></pre><p>你不能更改指针指向的位置，除非赋值另外一个地址给它。同时也就不支持 <a href="https://maryash.github.io/135/slides/7.2%20Arrays%20and%20Pointers.pdf">Array-Pointer Duality</a>。</p><ol start="2"><li>base type 不同的指针值，无法直接互相赋值</li></ol><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int64</span><span class="hljs-keyword">type</span> Ta    *<span class="hljs-keyword">int64</span><span class="hljs-keyword">type</span> Tb    *MyInt<span class="hljs-comment">// 4 nil pointers of different types.</span><span class="hljs-keyword">var</span> pa0 Ta<span class="hljs-keyword">var</span> pa1 *<span class="hljs-keyword">int64</span><span class="hljs-keyword">var</span> pb0 Tb<span class="hljs-keyword">var</span> pb1 *MyInt   <span class="hljs-comment">// None of the following 3 lines compile ok.</span><span class="hljs-comment">/*</span><span class="hljs-comment">_ = pa0 == pb0</span><span class="hljs-comment">_ = pa1 == pb1</span><span class="hljs-comment">_ = pa0 == Tb(nil)</span><span class="hljs-comment">*/</span></code></pre><ol start="3"><li>返回局部变量的指针是安全的</li></ol><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> *<span class="hljs-title">int</span></span> &#123;   i := <span class="hljs-number">1</span>  <span class="hljs-keyword">return</span> &amp;i&#125;</code></pre><h3 id="指针总结"><a href="#指针总结" class="headerlink" title="指针总结"></a>指针总结</h3><p>使用过 C/C++ 语言的开发者，习惯使用的不安全的指针是 <code>unsafe.Pointer</code>，而非普通的指针。</p><pre><code class="hljs C++"><span class="hljs-keyword">int</span>* valFirst<span class="hljs-keyword">intptr_t</span> valSecond<span class="hljs-keyword">void</span>* valThird</code></pre><p>vs</p><pre><code class="hljs go"><span class="hljs-keyword">int</span>* valFirst<span class="hljs-keyword">type</span> intptr_t *<span class="hljs-keyword">int</span>intptr_t valSecondunsafe.Pointer valThird</code></pre><p>对比服用，效果更佳。</p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/08-16-2021/go-has-no-reference-and-safe-pointer.html">https://www.cyningsun.com/08-16-2021/go-has-no-reference-and-safe-pointer.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面向对象编程强调数据和操作绑定，方法是有状态的，本身可能会修改数据。因此编程时确定方法是否会修改原始数据尤其关键。多数从其他语言转到 Go 语言的开发者，都会首先了解 Go 语言传递参数的时候到底是 “传值” 还是 “传引用”。如果第一门开发语言是 C 语言或者 C++ 的
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Pointer" scheme="https://www.cyningsun.com/tag/Pointer/"/>
    
  </entry>
  
  <entry>
    <title>译｜What “accept interfaces, return structs” means in Go</title>
    <link href="https://www.cyningsun.com/08-08-2021/go-accept-interfaces-return-structs.html"/>
    <id>https://www.cyningsun.com/08-08-2021/go-accept-interfaces-return-structs.html</id>
    <published>2021-08-07T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.289Z</updated>
    
    <content type="html"><![CDATA[<p>“接受接口、返回结构” 的一般原则，我在前一篇文章中写到，也多次在代码评审时向同事介绍，但经常遇到“为什么”的疑问。特别是因为这不是一条硬性规定。该想法的关键在于保持灵活性的同时避免预先抽象，并理解何时改变它。</p><p><img src="/images/accept-interfaces-return-structs/gopher.png" alt="gopher.png"></p><h3 id="预先抽象使系统变得复杂"><a href="#预先抽象使系统变得复杂" class="headerlink" title="预先抽象使系统变得复杂"></a>预先抽象使系统变得复杂</h3><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，当然，间接过多的问题除外 - David J. Wheeler</p></blockquote><p>软件工程师喜欢抽象。就我个人而言，从未见过编写代码比创建抽象更投入的同事。Go 中，接口抽象脱离了结构，该间接层甚至没有最低层次的嵌入复杂性。遵循软件设计 <a href="http://c2.com/xp/YouArentGonnaNeedIt.html">您不会用到它</a> 的哲学，在需要之前制造这种复杂性毫无意义。函数调用返回接口的一个常见原因是让用户专注于函数开放的 API。因为有隐式接口，Go 不需要这样做。结构的 public function iu 就是其 API。</p><blockquote><p>总是当 <strong>真正</strong> 需要时 [抽象]，不要当 <strong>预见</strong> 需要时 [抽象]。</p></blockquote><p>某些语言要求你预见未来需要的每个接口。隐式接口的一大优点是，它们允许事后进行优雅的抽象，而无需预先进行抽象。</p><h3 id="因人而异的“需要”"><a href="#因人而异的“需要”" class="headerlink" title="因人而异的“需要”"></a>因人而异的“需要”</h3><blockquote><p>当真正需要时</p></blockquote><p>如何定义何时需要抽象？对于返回类型，这很容易。你是编写该函数的人，因此您确切知道何时需要将返回值抽象。</p><p>对于函数输入，需求不在你的控制范围之内。你可能认为 database struct 就足够了，但用户可能需要用其他东西装饰它。就算不是不可能，预测每个人使用你的函数的状态也是很困难的。能够精确控制输出，但无法预测用户输入。相比对输出的抽象化，这种不平衡造成了对输入的抽象化更强烈的偏重。</p><h3 id="去除不必要的代码细节"><a href="#去除不必要的代码细节" class="headerlink" title="去除不必要的代码细节"></a>去除不必要的代码细节</h3><p><img src="/images/accept-interfaces-return-structs/recipes.png" alt="recipes.png"></p><p>简化的另一方面是去除不必要的细节。函数就像烹饪食谱：给定输入，就会得到一个蛋糕！没有食谱会列出不需要的配料。类似地，函数也不应该列出不需要的输入。你如何看以下函数？</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addNumbers</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>, s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;     <span class="hljs-keyword">return</span> a + b &#125;</code></pre><p>对于大多数程序员来说，很明显，参数 s 不恰当。当参数是结构时，却不太明显。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Database <span class="hljs-keyword">struct</span>&#123; &#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Database)</span> <span class="hljs-title">AddUser</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> &#123;...&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Database)</span> <span class="hljs-title">RemoveUser</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> &#123;...&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUser</span><span class="hljs-params">(d *Database, firstName <span class="hljs-keyword">string</span>, lastName <span class="hljs-keyword">string</span>)</span></span> &#123;     d.AddUser(firstName + lastName) &#125;</code></pre><p>就像配料太多的食谱一样，NewUser 接收一个可以做太多事情的 Database 对象。它只需要 AddUser，但接收的参数还有 RemoveUser。使用接口创建的函数，可以只依赖于必需。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> DatabaseWriter <span class="hljs-keyword">interface</span> &#123;     AddUser(<span class="hljs-keyword">string</span>) &#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUser</span><span class="hljs-params">(d DatabaseWriter, firstName <span class="hljs-keyword">string</span>, lastName <span class="hljs-keyword">string</span>)</span></span> &#123;     d.AddUser(firstName + lastName) &#125;</code></pre><p>Dave Cheney 在描述 <a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">接口隔离原则</a> 时 <a href="https://dave.cheney.net/2016/08/20/solid-go-design">写到了这一点</a>。他还描述了限制输入的其他优点，值得一读。让人理解这个想法的总目标是：</p><blockquote><p>结果同时是一个函数，它的要求是最具体的——它只需要一个可写的东西——并且它的函数是最通用的</p></blockquote><p>我只想补充一点，上面的函数 addNumber 显然不应该有参数字符串 s，函数 NewUser 理想情况下不需要可以删除用户的 database。</p><h3 id="总结原因并审查例外"><a href="#总结原因并审查例外" class="headerlink" title="总结原因并审查例外"></a>总结原因并审查例外</h3><p>主要原因如下：</p><ul><li>去除不需要的抽象</li><li>用户对函数输入需求是模糊的</li><li>简化函数输入</li></ul><p>以上原因还允许我们定义规则的例外情况。例如，如果函数需要返回多种类型，那么显然返回需要定义为接口。类似地，如果函数是私有的，那么函数输入便并不模糊，因为你可以控制它，所以倾向于非预先抽象。对于第三条规则，go 没有办法抽象出 struct 成员的值。因此，如果你的函数需要访问结构体成员（而不仅仅是结构体上的函数），那么您将被迫直接接受结构体。</p><p><em>原文：</em>  <a href="https://medium.com/@cep21/what-accept-interfaces-return-structs-means-in-go-2fe879e25ee8">What “accept interfaces, return structs” means in Go</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/08-08-2021/go-accept-interfaces-return-structs.html">https://www.cyningsun.com/08-08-2021/go-accept-interfaces-return-structs.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“接受接口、返回结构” 的一般原则，我在前一篇文章中写到，也多次在代码评审时向同事介绍，但经常遇到“为什么”的疑问。特别是因为这不是一条硬性规定。该想法的关键在于保持灵活性的同时避免预先抽象，并理解何时改变它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/accept
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Interface" scheme="https://www.cyningsun.com/tag/Interface/"/>
    
  </entry>
  
  <entry>
    <title>如何用好 Go interface</title>
    <link href="https://www.cyningsun.com/08-02-2021/using-golang-interface-well.html"/>
    <id>https://www.cyningsun.com/08-02-2021/using-golang-interface-well.html</id>
    <published>2021-08-01T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.289Z</updated>
    
    <content type="html"><![CDATA[<p><code>interface</code> 是 Go 语言最精髓的特性之一，一直以来想写一篇关于 <code>interface</code> 的文章，但是一直没敢写。持续几年之久，还是斗胆总结下。</p><h3 id="Concrete-types"><a href="#Concrete-types" class="headerlink" title="Concrete types"></a>Concrete types</h3><p>struct 定义数据的内存布局。一些早期建议将方法包含在 struct 中，但是被放弃了。相反，方法如普通函数一样声明在类型之外。描述 (data) 和行为 (methods) 是独立且正交的。</p><p>一方面，方法只是一个带有 “receiver” 参数的函数。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123; x, y float &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Point)</span> <span class="hljs-title">Abs</span><span class="hljs-params">()</span> <span class="hljs-title">float</span></span> &#123;    <span class="hljs-keyword">return</span> math.Sqrt(p.x*p.x + p.y*p.y)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Abs</span><span class="hljs-params">(p Point)</span> <span class="hljs-title">float</span></span> &#123;<span class="hljs-keyword">return</span> math.Sqrt(p.x*p.x + p.y*p.y)&#125;</code></pre><p><code>Abs</code> 编写为一个常规函数，功能没有变化。</p><blockquote><p>什么时候应该使用方法，什么时候应该使用函数呢？如果方法不依赖类型的状态，则应该将其定义为函数。</p></blockquote><p>另一方面，方法在定义其行为时，使用了类型的值时，与所附加的类型紧密关联。方法可以从对应的类型中获取值，如果有指针 “receiver”，还可以操纵其状态。</p><p>“类型” 有时候很有用，有时候又很讨厌。因为类型是对底层内存布局的一个抽象，会让代码关注于非业务逻辑上的东西，然而代码又需要在不同类型的数据间做处理。interface 就是其中一种泛型解决方案。</p><pre><code class="hljs go"><span class="hljs-comment">// Package sort provides primitives for sorting slices and user-defined collections.</span><span class="hljs-keyword">package</span> sort<span class="hljs-comment">// An implementation of Interface can be sorted by the routines in this package.</span><span class="hljs-comment">// The methods refer to elements of the underlying collection by integer index.</span><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<span class="hljs-comment">// Len is the number of elements in the collection.</span>Len() <span class="hljs-keyword">int</span><span class="hljs-comment">// Less reports whether the element with index i</span><span class="hljs-comment">// must sort before the element with index j.</span>Less(i, j <span class="hljs-keyword">int</span>) <span class="hljs-keyword">bool</span><span class="hljs-comment">// Swap swaps the elements with indexes i and j.</span>Swap(i, j <span class="hljs-keyword">int</span>)&#125;<span class="hljs-comment">// Sort sorts data.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span><span class="hljs-params">(data Interface)</span></span> &#123;    ...&#125;</code></pre><h3 id="Abstract-types"><a href="#Abstract-types" class="headerlink" title="Abstract types"></a>Abstract types</h3><p>Go 的 interface 仅仅是函数的集合，也定义了行为。 interface 与类型之间没有显式的关系，类型也可以同时满足多个 interface 的要求。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Abser <span class="hljs-keyword">interface</span> &#123;    Abs() float &#125;  <span class="hljs-keyword">var</span> a Abser a = Point&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125; <span class="hljs-built_in">print</span>(a.Abs()) a = Vector&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125; <span class="hljs-built_in">print</span>(a.Abs())</code></pre><p>Point 和 Vector 满足 Abser 的要求同时，也符合 interface{} 的要求。不同的是，interface{} 没有任何行为（method）。</p><h3 id="When-amp-How"><a href="#When-amp-How" class="headerlink" title="When &amp; How"></a>When &amp; How</h3><p>道理我都懂，但是何时使用，如何使用 interface 呢？</p><p>答案是，当不需要关心实现细节的时候？</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn</span><span class="hljs-params">(Parameter)</span> <span class="hljs-title">Result</span></span></code></pre><p>当函数编写者希望隐藏实现细节时，应该把 Result 设定为 interface；当函数编写者希望提供扩展点的时候，应当把 Parameter 设定为 interface；</p><h4 id="隐藏实现细节"><a href="#隐藏实现细节" class="headerlink" title="隐藏实现细节"></a>隐藏实现细节</h4><p>以 CancelCtx 为例:</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;Deadline() (deadline time.Time, ok <span class="hljs-keyword">bool</span>)Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;Err() errorValue(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;&#125;<span class="hljs-comment">// newCancelCtx returns an initialized cancelCtx.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCancelCtx</span><span class="hljs-params">(parent Context)</span> <span class="hljs-title">cancelCtx</span></span> &#123;<span class="hljs-keyword">return</span> cancelCtx&#123;Context: parent&#125;&#125;<span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> &#123;...&#125;</code></pre><p>newCancelCtx 返回值为 <code>cancelCtx</code>。注意到 cancelCtx 是没有导出的，意味着使用者只能使用 Context 的变量来接收 newCancelCtx 返回值，从而达到隐藏实现的目的。cancelCtx 是否还有其他方法，以及具体如何实现，使用者并无感知。</p><h4 id="提供扩展点"><a href="#提供扩展点" class="headerlink" title="提供扩展点"></a>提供扩展点</h4><p>当我们需要将文档持久化</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Document <span class="hljs-keyword">struct</span> &#123;    ...&#125;<span class="hljs-comment">// Save writes the contents of the Document to the file f.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Document)</span> <span class="hljs-title">Save</span><span class="hljs-params">(f *os.File)</span> <span class="hljs-title">error</span></span></code></pre><p>假如实现如上，Save 方法将 *os.File 作为写入的目标。但是此实现存在一些问题：</p><ol><li>该实现排除了将数据写入网络位置的选项。假设网络存储成为需求，则此函数的签名必须更改，从而影响其所有调用者。</li><li>该实现很难测试。为了验证其操作，测试必须在写入文件后读取文件的内容。还必须确保 f 被写入到临时位置，并始终在之后删除。</li><li>*os.File 暴露了许多与 Save 无关的方法，比如读取目录和检查路径是否为符号链接。</li></ol><p>可以使用接口隔离原则重新定义该方法，优化实现为：</p><pre><code class="hljs go"><span class="hljs-comment">// Save writes the contents of d to the supplied ReadWriterCloser.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Document)</span> <span class="hljs-title">Save</span><span class="hljs-params">(rwc io.ReadWriteCloser)</span> <span class="hljs-title">error</span></span></code></pre><p>然而，此方法仍然违反单一职责原则，它同时负责读取和验证写入的内容。将此部分责任拆分走，继续优化为：</p><pre><code class="hljs go"><span class="hljs-comment">// Save writes the contents of d to the supplied WriteCloser.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Document)</span> <span class="hljs-title">Save</span><span class="hljs-params">(wc io.WriteCloser)</span> <span class="hljs-title">error</span></span></code></pre><p>然而，wc 会在什么情况下关闭。可能 Save 将无条件调用 Close，或者在成功的情况下调用 Close，以上都不是一个好的选择。因此再次优化</p><pre><code class="hljs go"><span class="hljs-comment">// WriteTo writes the contents of d to the supplied Writer.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Document)</span> <span class="hljs-title">WriteTo</span><span class="hljs-params">(w io.Writer)</span> <span class="hljs-title">error</span></span></code></pre><p>接口声明了调用方需要的行为，而不是类型将提供的行为。行为的提供方具有高度的扩展空间，例如：装饰器模式扩展该行为。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> LogWriter <span class="hljs-keyword">struct</span> &#123;    w  io.Writer&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LogWriter)</span><span class="hljs-title">Write</span><span class="hljs-params">(p []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span> &#123;    fmt.Printf(<span class="hljs-string">&quot;write len:%v&quot;</span>, <span class="hljs-built_in">len</span>(p))    <span class="hljs-keyword">return</span> l.w.Write(r)&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于 interface，很喜欢以下两句箴言：</p><blockquote><p> Program to an ‘interface’, not an ‘implementation’ —— GoF<br> Be conservative in what you do, be liberal in what you accept from others —— Robustness Principle</p></blockquote><p>而不是</p><blockquote><p>Return concrete types, receive interfaces as parameter<br>（由 cancelCtx 的例子可知，如果其类型是导出的 CancelCtx，返回 concrete types 与以上箴言是有出入的）</p></blockquote><p>高级语言赋予了开发者高级的能力，让开发者不要关注具体值、类型，集中精力去处理业务逻辑（行为，method），interface 提供的就是这种能力。除了 interface，其他问题处理也是基于类似的思路：</p><blockquote><p><a href="/09-09-2019/dont-just-check-errors-handle-them-gracefully-cn.html">Don’t just check errors, handle them gracefully</a><br>基于行为处理错误，而不是基于值或类型</p></blockquote><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/08-02-2021/using-golang-interface-well.html">https://www.cyningsun.com/08-02-2021/using-golang-interface-well.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;interface&lt;/code&gt; 是 Go 语言最精髓的特性之一，一直以来想写一篇关于 &lt;code&gt;interface&lt;/code&gt; 的文章，但是一直没敢写。持续几年之久，还是斗胆总结下。&lt;/p&gt;
&lt;h3 id=&quot;Concrete-types&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Interface" scheme="https://www.cyningsun.com/tag/Interface/"/>
    
  </entry>
  
  <entry>
    <title>一个优雅的 LRU 缓存实现</title>
    <link href="https://www.cyningsun.com/07-26-2021/go-a-graceful-lru-implement.html"/>
    <id>https://www.cyningsun.com/07-26-2021/go-a-graceful-lru-implement.html</id>
    <published>2021-07-25T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.289Z</updated>
    
    <content type="html"><![CDATA[<p>Golang 的各种组件很灵活也很强大，但对于初级入门的使用者来说，要用好着实不易。最近，在开发一个可以拿来即用的 golang 库。第一个组件选择了缓存，主要是因为这个组件非常的关键，但也非常不容易实现好。</p><h3 id="第一步：定义-Cache-接口"><a href="#第一步：定义-Cache-接口" class="headerlink" title="第一步：定义 Cache 接口"></a>第一步：定义 Cache 接口</h3><p>设计一个高扩展的缓存包，就需要利用 <a href="/08-03-2019/solid-go-design-cn.html">里氏替换原则（Liskov Substitution Principle）</a>，做好抽象，将缓存定义为接口</p><pre><code class="hljs ada"><span class="hljs-keyword">type</span> <span class="hljs-type">Cache </span><span class="hljs-keyword">interface</span> &#123;    ...&#125;</code></pre><h3 id="第二步：组织包结构"><a href="#第二步：组织包结构" class="headerlink" title="第二步：组织包结构"></a>第二步：组织包结构</h3><p>然后，实现一个具体的 LRU 缓存，那么此时首先要组织好包结构，如下：</p><pre><code class="hljs bash">|-cache| |-lru| | |-lru.go| | |-segment.go| | |-options.go| | |-expvar.go|-cache.go</code></pre><p><a href="/03-03-2021/packages-as-layers-not-groups-cn.html">利用包划分层次</a>，将接口放在根包下，作为所有子包的通用语言：</p><pre><code class="hljs ada">// cache.go<span class="hljs-keyword">package</span> <span class="hljs-title">edge</span><span class="hljs-keyword">type</span> <span class="hljs-type">Cache </span><span class="hljs-keyword">interface</span> &#123;    ...&#125;</code></pre><h3 id="第三步：实现-LRU-缓存"><a href="#第三步：实现-LRU-缓存" class="headerlink" title="第三步：实现 LRU 缓存"></a>第三步：实现 LRU 缓存</h3><ol><li>为了防止锁竞争导致的性能低下，此处使用分段加锁的方式降低锁粒度以提高缓存性能</li><li>同时将 <code>segment</code>、<code>newSegment</code>、<code>cache</code> 以小写命名，避免对外暴露实现细节</li><li>使用 <a href="/07-19-2021/go-higher-order-function.html"><code>Higher-order function</code></a>，实现可扩展的配置参数</li><li>使用 <code>expvar</code> 暴露缓存的状态</li></ol><pre><code class="hljs go"><span class="hljs-comment">// lru.go</span><span class="hljs-keyword">package</span> lru<span class="hljs-keyword">type</span> cache <span class="hljs-keyword">struct</span> &#123;    ...&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(opts ...Opt)</span> <span class="hljs-params">(*cache, error)</span></span> &#123;    ...&#125;<span class="hljs-comment">// segment.go</span><span class="hljs-keyword">package</span> lru<span class="hljs-keyword">type</span> segment <span class="hljs-keyword">struct</span> &#123;    ...&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSegment</span><span class="hljs-params">(c <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">segment</span></span> &#123;    ...&#125;<span class="hljs-comment">// options.go</span><span class="hljs-keyword">type</span> options <span class="hljs-keyword">struct</span> &#123;    ...&#125;<span class="hljs-keyword">type</span> Opt <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*options)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithConcurrency</span><span class="hljs-params">(c <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">Opt</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *options)</span></span> &#123;o.concurrency = c&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCapacity</span><span class="hljs-params">(c <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">Opt</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *options)</span></span> &#123;o.capacity = c&#125;&#125;<span class="hljs-comment">// expvar.go</span><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">struct</span> &#123;Get    *expvar.IntSet    *expvar.IntDelete *expvar.IntExists *expvar.IntHit    *expvar.IntEvict  *expvar.Int&#125;&#123;Get:    expvar.NewInt(<span class="hljs-string">&quot;cache.lru.get&quot;</span>),Set:    expvar.NewInt(<span class="hljs-string">&quot;cache.lru.set&quot;</span>),Delete: expvar.NewInt(<span class="hljs-string">&quot;cache.lru.delete&quot;</span>),Exists: expvar.NewInt(<span class="hljs-string">&quot;cache.lru.exists&quot;</span>),Hit:    expvar.NewInt(<span class="hljs-string">&quot;cache.lru.hit&quot;</span>),Evict:  expvar.NewInt(<span class="hljs-string">&quot;cache.lru.evict&quot;</span>),&#125;</code></pre><h3 id="第四步：结束了么？"><a href="#第四步：结束了么？" class="headerlink" title="第四步：结束了么？"></a>第四步：结束了么？</h3><p>当然没有，从以上可以看到，以下几点：</p><ol><li>options 可以做到多种实现共用，更应该放在 cache 文件夹下。</li><li>在使用时，lru.New() 赋值给 Cache 接口略微不自然</li><li>segment.go 和 expvar.go 未对使用者开放但文件却对外暴露</li><li>segment 可能后续会用来实现其他缓存算法，也不适合放在 lru 包下</li></ol><p>基于以上原因，再次调整包结构如下：</p><pre><code class="hljs bash">|-cache| |-options.go| |-lru.go|-cache.go|-internal| |-cache| | |-lru| | | |-expvar.go| | | |-segment.go</code></pre><p>同时，调整 LRU 缓存的接口为：</p><pre><code class="hljs go"><span class="hljs-comment">// cache.go</span><span class="hljs-keyword">package</span> cache<span class="hljs-keyword">type</span> cache <span class="hljs-keyword">struct</span> &#123;    ...&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLRU</span><span class="hljs-params">(opts ...Opt)</span> <span class="hljs-params">(*cache, error)</span></span> &#123;    ...&#125;</code></pre><p>是不是自然了很多，使用示例：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> c edge.Cache = cache.NewLRU()</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>学以致用，此 LRU 的实现应用了很多之前的知识。追求优秀代码的路是没有尽头的，下课。</p><p>源代码：<a href="https://github.com/cyningsun/edge">github.com/cyningsun/edge</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/07-26-2021/go-a-graceful-lru-implement.html">https://www.cyningsun.com/07-26-2021/go-a-graceful-lru-implement.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Golang 的各种组件很灵活也很强大，但对于初级入门的使用者来说，要用好着实不易。最近，在开发一个可以拿来即用的 golang 库。第一个组件选择了缓存，主要是因为这个组件非常的关键，但也非常不容易实现好。&lt;/p&gt;
&lt;h3 id=&quot;第一步：定义-Cache-接口&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Programming style" scheme="https://www.cyningsun.com/tag/Programming-style/"/>
    
  </entry>
  
  <entry>
    <title>Go 函数式编程：Higher-order function</title>
    <link href="https://www.cyningsun.com/07-19-2021/go-higher-order-function.html"/>
    <id>https://www.cyningsun.com/07-19-2021/go-higher-order-function.html</id>
    <published>2021-07-18T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.289Z</updated>
    
    <content type="html"><![CDATA[<p>在请求处理过程中，应用程序会接受和处理请求，然后返回响应结果。在该过程中，还存在一些通用的功能，例如：鉴权、监控、链路追踪。众多 RPC 框架会提供称之为 Middleware 或者 Interceptor 等概念，以可插拔的方式来支持上述谈到的众多功能。以 gRPC 为例，工作原理如图：</p><p><img src="/images/go-higher-order-function/grpc-interceptors.png" alt="grpc-interceptors.png"></p><p>其服务端的接口如下所示：</p><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UnaryServerInterceptor</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StreamServerInterceptor</span> <span class="hljs-params">(srv <span class="hljs-keyword">interface</span>&#123;&#125;, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler)</span> <span class="hljs-title">error</span></span></code></pre><p>可以看到，接口明确定义了输入参数，输出结果。如果我们要自己实现一个组件，需要支持使用者传入特定的配置，有没有什么办法可以做到呢？</p><p>答案是肯定的。</p><h3 id="Higher-order-function"><a href="#Higher-order-function" class="headerlink" title="Higher-order function"></a>Higher-order function</h3><p>在了解具体的解决方案之前，需要先了解一个概念叫<code>Higher-order function（高阶函数）</code></p><p>高阶函数是指至少支持以下特定之一的函数：</p><ol><li>将一个或多个函数作为参数（即过程参数），</li><li>返回函数作为其结果</li></ol><p>第二点，正是需要的特性。以限流的 interceptor 为例，支持传入自定义的限流器。此时就需要定义一个以限流器为参数的高阶函数，然后返回的函数是框架需要的 Interceptor，并在 Interceptor 函数内使用传入的限流器判断是否需要限流。按照接口限流的 Interceptor 具体实现为：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Limiter <span class="hljs-keyword">interface</span> &#123;Limit(key <span class="hljs-keyword">string</span>) <span class="hljs-keyword">bool</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UnaryServerInterceptor</span><span class="hljs-params">(limiter Limiter)</span> <span class="hljs-title">grpc</span>.<span class="hljs-title">UnaryServerInterceptor</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<span class="hljs-keyword">if</span> limiter.Limit(info.FullMethod) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, status.Errorf(codes.ResourceExhausted, <span class="hljs-string">&quot;%s is rejected by grpc_ratelimit middleware, please retry later.&quot;</span>, info.FullMethod)&#125;<span class="hljs-keyword">return</span> handler(ctx, req)&#125;&#125;...</code></pre><p>目前传入的参数是固定的，可以这么来实现。更进一步，如果使用比较复杂，除了当前已经确定的参数，可以预期以后会增加更多的参数。也就要求当前设计的接口需要有很好的扩展性。还有办法么？</p><p>答案同样是肯定的。</p><h3 id="Functional-Options"><a href="#Functional-Options" class="headerlink" title="Functional Options"></a>Functional Options</h3><p>没有意外，利用的就是高阶函数的第一点，该编程模式有一个特定的名称：Functional Options。</p><p>首先为传入的参数定义结构体</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> options <span class="hljs-keyword">struct</span> &#123;    byMethod  <span class="hljs-keyword">bool</span>    byUser    <span class="hljs-keyword">bool</span>    byClientIP <span class="hljs-keyword">bool</span>&#125;</code></pre><p>其次，再定义一个函数类型：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Option <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Options)</span></span></code></pre><p>再次，定义修改配置的一组函数</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ByMethod</span><span class="hljs-params">(m <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">Option</span></span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *options)</span></span> &#123;        o.byMethod = m    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ByUser</span><span class="hljs-params">(u <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">Option</span></span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *options)</span></span> &#123;        o.byUser = u    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ByClientIP</span><span class="hljs-params">(c <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">Option</span></span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *options)</span></span> &#123;        o.byClientIP = c    &#125;&#125;</code></pre><p>最后，修改提供的 Interceptor 为：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UnaryServerInterceptor</span><span class="hljs-params">(limiter Limiter, opts ...Option)</span> <span class="hljs-title">grpc</span>.<span class="hljs-title">UnaryServerInterceptor</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;        <span class="hljs-keyword">default</span> := options &#123;            byMethod: <span class="hljs-literal">true</span>,            byUser: <span class="hljs-literal">false</span>,            byClientIP: <span class="hljs-literal">false</span>,        &#125;        <span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> opts &#123;            opt(&amp;<span class="hljs-keyword">default</span>)        &#125;        ...<span class="hljs-keyword">return</span> handler(ctx, req)&#125;&#125;</code></pre><p>如是，你就拥有了一个具有扩展性、支持自定义参数的 Interceptor。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>做个总结，谈个观点：</p><ol><li>高阶函数，并不是属于哪一个特定的编程语言。其他语言如C++，同样支持类似的特性。</li><li>作为架构师需要了解实现细节么，答案是需要。否则，在特定环境下，拿什么来支撑设计所谓的扩展性呢。</li></ol><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/07-19-2021/go-higher-order-function.html">https://www.cyningsun.com/07-19-2021/go-higher-order-function.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在请求处理过程中，应用程序会接受和处理请求，然后返回响应结果。在该过程中，还存在一些通用的功能，例如：鉴权、监控、链路追踪。众多 RPC 框架会提供称之为 Middleware 或者 Interceptor 等概念，以可插拔的方式来支持上述谈到的众多功能。以 gRPC 为例
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Functional programming" scheme="https://www.cyningsun.com/tag/Functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>译｜Eventually Consistent</title>
    <link href="https://www.cyningsun.com/06-26-2021/eventually-consistent-cn.html"/>
    <id>https://www.cyningsun.com/06-26-2021/eventually-consistent-cn.html</id>
    <published>2021-06-25T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.289Z</updated>
    
    <content type="html"><![CDATA[<p>一年前，我写过一致性模型的文章的<a href="http://www.allthingsdistributed.com/2007/12/eventually_consistent.html">第一个版本</a>。因为当时写的很匆忙，而且这个主题非常重要，值得更缜密的对待，所以我并不是很满意。ACM Queue 为将其发布到自己觉得杂志上，所以请我仔细推敲。我得以借此机会改进这篇文章。本文就是最新的版本。</p><h3 id="最终一致性-在全球范围内构建可靠的分布式系统需要在一致性和可用性之间进行权衡。"><a href="#最终一致性-在全球范围内构建可靠的分布式系统需要在一致性和可用性之间进行权衡。" class="headerlink" title="最终一致性 - 在全球范围内构建可靠的分布式系统需要在一致性和可用性之间进行权衡。"></a>最终一致性 - 在全球范围内构建可靠的分布式系统需要在一致性和可用性之间进行权衡。</h3><p>亚马逊云计算的基础是诸如 S3（Simple Storage Service）、SimpleDB、EC2（Elastic Compute Cloud）等基础设施，为构建互联网规模级别计算平台和种类繁多的应用提供了资源。这些基础设施服务的要求非常严格，需要在安全性、可扩展性、可用性、性能和成本效益方面获得高分，与此同时还要持续为全球数以百万计的客户提供服务。</p><p>在这些服务幕后，是全球范围内运行的大规模分布式系统。这种规模带来了额外的挑战。因为当系统处理数以万亿计的请求时，通常情况下发生概率较低的的事件会必然发生，需要在系统设计和架构中预先考虑。鉴于这些系统遍及全球范围，我们通常使用复制技术来保证一致性的性能和高可用性。尽管复制使我们更接近目标，却不能以完全透明的方式实现这些目标。在许多情况下，这些服务的客户将面临服务内部使用复制技术的后果。</p><p>其中一种表现方式是提供的数据一致性的类型，特别是底层分布式系统为数据复制提供最终一致性模型时。在亚马逊设计这些大规模系统时，使用了一套与大规模数据复制相关的指导原则和抽象方法，并专注于高可用性和数据一致性之间的平衡。在本文中，我介绍了一些相关的背景知识，包含了我们交付需要在全球范围内运行的可靠分布式系统的方法。本文的<a href="http://www.allthingsdistributed.com/2007/12/eventually_consistent.html">早期版本</a>于 2007 年 12 月在 All Things Distributed 博客上发表，在读者的帮助下得到了极大的改进。</p><h3 id="历史视角"><a href="#历史视角" class="headerlink" title="历史视角"></a>历史视角</h3><p>在理想世界里，只有一种一致性模型：当更新发生时，所有观察者都能看到那个更新。该模型第一次出现难以实现的情况是在70年代末的数据库系统中。关于该主题最好的“时期作品”是 <a href="http://acmqueue.com/modules.php?name=Content&pa=showpage&pid=233">Bruce Lindsay 等人的</a>”分布式数据库笔记”。 它阐述了数据库复制的基础性原则，并讨论了许多处理实现一致性的技术。其中许多技术都试图实现分发透明性——即对系统用户来说，似乎只有一个系统而不是多个协作系统。在此期间，许多系统采取的做法是倾向于让整个系统失败，而非破坏其透明度。</p><p>在90年代中期，随着大型互联网系统的兴起，这些做法被重新审视。当时的人们开始考虑可用性可能是这些系统最重要的属性的想法，但他们正在为拿什么权衡而苦苦挣扎。加州大学伯克利分校系统教授、当时的 Inktomi 负责人 <a href="http://www.cs.berkeley.edu/~brewer/">Eric Brewer</a> 在 2000 年 PODC（分布式计算原理）会议上的<a href="http://www.cs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf">主题演讲</a>中将不同的权衡结合在一起。他提出了 CAP 定理，该定理指出共享数据系统的三个属性——数据一致性、系统可用性和对网络分区的容忍度——在任何给定时间只能实现两个。更正式的认定可以在 <a href="http://portal.acm.org/citation.cfm?doid=564585.564601">Seth Gilbert 和 Nancy Lynch</a> 2002 年的一篇论文中找到。</p><p>一个不容忍网络分区的系统可以实现数据的一致性和可用性，通常通过使用事务协议来实现。要实现这一点，客户端和存储系统必须是同一环境的一部分；在某些情况下，它们作为一个整体失败，因此，客户端无法观察到分区。一个重要的观察结果是，在较大的分布式系统中，网络分区是给定的；因此，一致性和可用性无法同时实现。这意味着对于要删除的内容有两种选择：放宽一致性将允许系统在可分区条件下保持高可用性，而将一致性作为优先级意味着在某些条件下系统将不可用。</p><p>两种选项都要求客户端开发者了解系统提供的内容。如果系统强调一致性，开发者需要处理系统可能不可用的事实，例如：写入。如果因为系统不可用写操作失败，那么开发者不得不处理如何处置要写入的数据。如果系统强调可用性，那么总能接受写操作，但是在某些情况下，读操作不会反映最近完成的写入的结果。然后，开发人员必须决定客户端是否需要始终访问绝对最新的更新。大量的应用程序可以处理稍微陈旧的数据，并且在此模型下可以很好地提供服务。</p><p>原则上，<a href="http://en.wikipedia.org/wiki/ACID">ACID</a> 属性（原子性、一致性、隔离性、持久性）中定义的事务系统的一致性属性是一种不同的一致性保证。在 ACID 中，一致性是指当事务完成时，数据库处于一致状态的保证；例如，当从一个账户向另一个账户转账时，两个账户中持有的总金额不应改变。在基于 ACID 的系统中，这种一致性通常是编写事务的开发人员的责任，但可以由数据库管理完整性约束来辅助。</p><h3 id="一致性-——-客户端和服务器"><a href="#一致性-——-客户端和服务器" class="headerlink" title="一致性 —— 客户端和服务器"></a>一致性 —— 客户端和服务器</h3><p>有两种看待一致性的方法。一种是从开发人员/客户的角度来看：他们如何观察数据更新。第二种方式来自服务器端：更新如何流经系统以及系统可以为更新提供什么保证。</p><h4 id="客户端一致性"><a href="#客户端一致性" class="headerlink" title="客户端一致性"></a>客户端一致性</h4><p>客户端具有以下组件：</p><ul><li><p><strong>一个存储系统。</strong> 目前我们将其视为一个黑匣子，但人们应该假设在它幕后是大规模和高度分布式的，并且构建它是为了保证持久性和可用性。</p></li><li><p><strong>进程A。</strong> 这是一个对存储系统进行写入和读取的进程。</p></li><li><p><strong>进程B和C。</strong> 这两个进程独立于进程A，对存储系统进行读写操作。它们是真正的进程还是同一进程中的线程无关紧要；重要的是它们是独立的，共享信息需要通信。</p></li></ul><p>客户端一致性与观察者（在本例中为进程 A、B 或 C）如何以及何时查看对存储系统中的数据对象所做的更新有关。在以下说明不同类型一致性的示例中，进程 A 对数据对象进行了更新：</p><ul><li><p><strong>强一致性（Strong consistency）。</strong> 更新完成后，任何后续访问（通过 A、B 或 C）都将返回更新后的值。</p></li><li><p><strong>弱一致性（Weak consistency）。</strong> 系统不保证后续访问将返回更新后的值。在返回值之前需要满足许多条件。更新和保证任何观察者总是看到更新值之间的时间段被称为不一致窗口。</p></li><li><p><strong>最终一致性（Eventual consistency）。</strong> 弱一致性的一种特殊形式；存储系统保证如果没有对对象进行新的更新，最终所有访问都将返回最后更新的值。如果没有发生故障，则可以根据通信延迟、系统负载以及复制方案中涉及的副本数量等因素确定不一致窗口的最大大小。最流行的实现最终一致性的系统是 DNS（域名系统）。名称的更新根据配置的模式并结合时间控制的缓存进行分发；最终，所有客户端都会看到更新。</p></li></ul><p>最终一致性模型有许多需要考虑的重要变种：</p><ul><li><p><strong>因果一致性（Causal consistency）。</strong> 如果进程 A 通知进程 B 已更新数据项，则进程 B 的后续访问将返回更新后的值，并且保证写入会取代较早的写入。与进程 A 没有因果关系的进程 C 的访问遵循正常的最终一致性规则。</p></li><li><p><strong>读写一致性（Read-your-writes consistency）。</strong> 这是一种重要的模型，其中进程 A 在更新数据项后，始终访问更新的值并且永远不会看到旧值。这是因果一致性模型的一个特例。</p></li><li><p><strong>会话一致性（Session consistency）.</strong> 这是前一模型的实用版本，其中进程在会话上下文中访问存储系统。只要会话存在，系统就保证读写一致性。如果会话由于某种故障场景而终止，则需要创建新会话，并且保证会话之间不会重叠。</p></li><li><p><strong>单调读一致性（Monotonic read consistency）.</strong> 如果进程看到了对象的特定值，则任何后续访问都将永远不会返回任何先前的值。</p></li><li><p><strong>单调写一致性（Monotonic write consistency）.</strong> 在这种情况下，系统保证通过同一进程串行化写入。不保证这种一致性级别的系统是出了名的难以编程。</p></li></ul><p>上述特性可以组合。例如，可以将单调读与会话一致性相结合。 从实践的角度来看，这两个特性（单调读取和读取你的写入）在最终一致性系统中是最可取的，但并非总是必需的。开发者使用这两个特性可以更加简单的构建应用程序，同时允许存储系统放宽一致性并提供高可用性。</p><p>正如您从这些变种中看到的那样，可能存在多种不同的情况。是否可以处理后果取决于特定的应用程序。</p><p>最终一致性并不是极致分布式系统的某些深奥特性。许多提供主备可靠性的现代 RDBMS（关系数据库管理系统）以同步和异步模式实现复制技术。在同步模式下，副本更新是事务的一部分。在异步模式下，更新延迟到达备份，通常是通过日志传送。在后一种模式下，如果主服务器在日志发送之前发生故障，从提升为主的副本中读取，将出现旧的、不一致的值。同样为了支持更好的可扩展读取性能，RDBMS 已经开始提供从备份读取的能力，这是提供最终一致性保证的经典案例，其中不一致窗口取决于日志传送的周期。</p><h4 id="服务器端一致性"><a href="#服务器端一致性" class="headerlink" title="服务器端一致性"></a>服务器端一致性</h4><p>在服务器端，我们需要更深入地了解更新如何流经系统，以了解是什么使得系统的开发人员可以感受到不同的模式。在开始之前，让我们先建立一些定义：</p><p>N = 存储数据副本的节点数<br>W = 更新完成前需要确认收到更新的副本数<br>R = 通过读取操作访问数据对象时联系的副本数</p><p>如果 W + R &gt; N，那么写集和读集始终存在重叠，可以保证强一致性。在实现同步复制技术的主备 RDBMS 场景中：N=2、W=2、R=1，无论客户端从哪个副本读取，总能得到一致的结果。在启用了从备份读取的异步复制中，N=2、W=1、R=1。这种情况下 R + W = N，无法保证一致性。</p><p>这些基本仲裁协议（quorum protocols）配置存在的问题是，当系统由于故障而无法写入 W 节点时，写入操作必须失败，这标志着系统不可用。当 N = 3 和 W = 3 且只有两个节点可用时，系统不得不使写入失败。</p><p>在高性能和高可用性的分布式存储系统中，副本的数量通常大于 2。仅关注容错的系统通常使用 N = 3（W = 2、R = 2）的配置。需要提供非常高的读取负载服务的系统，通常会复制超出容错所需的数据；N 可以是数十甚至数百节点，R 配置为 1，这样单次读取就能返回结果。关注一致性的系统设置为 W = N 以应对更新，这可能会降低写入成功的概率。对于关注容错但不关注一致性的系统，常见配置是以 W = 1 运行，以获得最小的更新持久性，然后依靠延迟（传播）技术来更新其他副本。</p><p>如何配置 N、W 和 R 取决于具体情况以及需要优化的性能路径。在 R = 1 和 N = W 中，我们针对读取情况进行了优化，在 W = 1 和 R = N 中，我们针对快速写入进行了优化。当然，在后一种情况下，出现故障时无法保证持久性，如果 W &lt; (N + 1) / 2，当写集不重叠时，存在冲突写入的可能性。</p><p>当 W+R &lt;= N 时出现弱/最终一致性，这意味着读写集有可能不会重叠。如果这是一个经过深思熟虑的配置，而不是基于失败案例，那么将 R 设置为 1 以外的任何值几乎没有意义。这发生在两种非常常见的情况下：第一种是前面提到的用于读扩展的大规模复制；第二种是数据访问更复杂的地方。在简单的键值模型中，比较版本以确定写入系统的最新值很容易，但在返回对象集的系统中，确定正确的最新集更困难。在大多数写入集小于副本集的系统中，有一种机制以延迟方式将更新应用于副本集中的其余节点。在所有副本都被更新之前的时间段是前面讨论的不一致窗口。如果 W+R &lt;= N，则系统容易从尚未收到更新的节点读取数据。</p><p>读写一致性、会话一致性和单调一致性能否实现，通常取决于客户端对与执行分布式协议服务器的“粘性”。如果每次都是同一台服务器，那么就比较容易保证读写和单调读写。同一台服务器使得管理负载平衡和容错稍微困难一些，却是一个简单的解决方案。使用具有粘性的会话易于理解，并提供客户可以推理的暴露级别。</p><p>有时客户端实现读写和单调读取。通过在写入时添加版本，客户端会丢弃对上次看到的版本之前版本的读取。</p><p>当系统中的某些节点无法连接到其他节点，但客户端组可以访问这两个节点集合时，就会发生分区。如果您使用经典的多数仲裁方法，则在另一个分区变得不可用时，具有复制集的 W 个节点的分区可以继续进行更新。读取集也是如此。假设这两个集合重叠，根据定义，少数集合将变得不可用。分区不经常发生，但它们确实发生在数据中心之间以及数据中心内部。</p><p>在某些应用程序中，任何分区的不可用都是不可接受的，重要的是可以让访问该分区的客户端继续运行。在这种情况下，双方分配一组新的存储节点来接收数据，并在分区愈合时执行合并操作。例如，在亚马逊内部，购物车使用一种永远写入的系统；在分区的情况下，即使原始购物车位于其他分区上，客户也可以继续将商品放入购物车。一旦分区恢复，购物车应用程序将协助存储系统合并购物车。</p><h3 id="亚马逊-Dynamo"><a href="#亚马逊-Dynamo" class="headerlink" title="亚马逊 Dynamo"></a>亚马逊 Dynamo</h3><p>亚马逊的 <a href="http://www.allthingsdistributed.com/2007/10/amazons_dynamo.html">Dynamo</a> 就是这样一个系统，将所有这些特性都置于应用程序体系结构的显式控制之下。它是一个键值存储系统，跟 AWS（Amazon’s Web Service）一样，在亚马逊电子商务平台的服务内部广泛使用。Dynamo 的设计目标之一是允许应用程序的所有者、创建 Dynamo 存储系统实例者，在一致性、持久性、可用性和性能之间进行权衡，而 Dynamo 存储系统通常跨越多个数据中心。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在大规模可靠的分布式系统中，有两个必须容忍数据不一致的原因：在高并发条件下改善读写性能；以及处理大多数模型会导致部分系统不可用的分区情况，即使节点已启动并正在运行。</p><p>不一致性是否可接受取决于客户端应用程序。在所有情况下，开发人员都需要意识到，一致性保证是由存储系统提供的，在开发应用程序时需要加以考虑。最终一致性模型有许多实际的改进，例如会话一致性和单调读，它们给开发人员提供了更好的工具。很多时候，应用程序能够毫无问题地处理存储系统的最终一致性保证。一个特别流行的例子是一个网站，在这个网站中我们可以有用户感知一致性的概念。在这种情况下，不一致窗口需要小于客户加载下一个页面的预期时间。使得在预期下一次读取之前，将更新传播到整个系统。</p><p>本文的目标是提高对工程系统复杂性的认识，这些系统需要在全球范围内运行，并且需要仔细调优，以确保它们能够提供应用程序所需的持久性、可用性和性能。系统设计者拥有的工具之一就是一致性窗口的长度，在此期间，系统的客户端可能会接触到大规模系统工程的实相。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li>Brewer, E. A. 2000. <a href="http://www.cs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf">Towards robust distributed systems (abstract)</a>. In <em>Proceedings of the 19th Annual ACM Symposium on Principles of Distributed Computing</em> (July 16-19, Portland, Oregon): 7</li><li><a href="http://acmqueue.com/modules.php?name=Content&pa=showpage&pid=233">A Conversation with Bruce Lindsay.</a> 2004. ACM Queue 2(8): 22-33.</li><li>DeCandia, G., Hastorun, D., Jampani, M., Kakulapati, G., Lakshman, A., Pilchin, A., Sivasubramanian, S., Vosshall, P., Vogels, W. 2007. <a href="http://www.allthingsdistributed.com/2007/10/amazons_dynamo.html">Dynamo: Amazon’s highly available key-value store</a>. In Proceedings of the 21st ACM <em>Symposium on Operating Systems Principles</em> (Stevenson, Washington, October).</li><li>Gilbert , S., Lynch, N. 2002. <a href="http://portal.acm.org/citation.cfm?doid=564585.564601">Brewer’s conjecture and the feasibility of consistent, available, partition-tolerant Web services</a>. ACM SIGACT News 33(2).</li><li>Lindsay, B. G., Selinger, P. G., et al. 1980. Notes on distributed databases. In <em>Distributed Data Bases, ed. I</em>. W. Draffan and F. Poole, 247-284. Cambridge: Cambridge University Press. Also available as IBM Research Report RJ2517, San Jose, California (July 1979).</li></ol><p>原文链接：<a href="http://www.allthingsdistributed.com/2008/12/eventually_consistent.html">http://www.allthingsdistributed.com/2008/12/eventually_consistent.html</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/06-26-2021/eventually-consistent-cn.html">https://www.cyningsun.com/06-26-2021/eventually-consistent-cn.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一年前，我写过一致性模型的文章的&lt;a href=&quot;http://www.allthingsdistributed.com/2007/12/eventually_consistent.html&quot;&gt;第一个版本&lt;/a&gt;。因为当时写的很匆忙，而且这个主题非常重要，值得更缜密的对待，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>内存管理 - 物理内存</title>
    <link href="https://www.cyningsun.com/06-15-2021/memory-management-physical-memory.html"/>
    <id>https://www.cyningsun.com/06-15-2021/memory-management-physical-memory.html</id>
    <published>2021-06-14T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.288Z</updated>
    
    <content type="html"><![CDATA[<p>本篇从我自己的角度来写对物理内存管理的理解。由于 Linux 引入了虚拟内存的概念，应用程序对物理内存的访问都是由内核模块来接管的，因此带着以下问题，逐步揭开相关的细节：</p><ol><li>内核是使用什么地址访问物理内存的？</li><li>物理内存为何需要分区？</li><li>伙伴系统和 SLAB 系统 有何区别？</li></ol><h3 id="页框管理"><a href="#页框管理" class="headerlink" title="页框管理"></a>页框管理</h3><p>想要管理内存，首先要知道有哪些内存，并且把内存状态记录下来。物理内存默认以 4k 分割为一个个的单元，每个单元被称为页框（page frame）。内核使用 <code>struct page</code> 数组跟踪内存中每个页框的当前状态。数组的每个元素对应于物理内存中的一个页框，数组定义如下：</p><pre><code class="hljs c"><span class="hljs-comment">// `struct page` 定义在 `linux/mm_types.h`</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">mem_map</span>;</span></code></pre><p>例如，mem_map[0] 包含内存中第一个页框的信息</p><blockquote><p>名词说明：</p><ul><li>页框: 存储数据的内存块</li><li>页：存放在页框内的数据块</li></ul></blockquote><p>如此，内核就通过页框数组把所有的内存使用索引了起来，并且知道每个页的情况，例如：是否空闲、拥有者是谁。</p><h3 id="为什么分区？"><a href="#为什么分区？" class="headerlink" title="为什么分区？"></a>为什么分区？</h3><p>然而对于内核来说仅有分页是不够的，内核也没办法 <strong>完全</strong> 直接访问内存，是什么原因呢？</p><p>具体还是要从内存分配过程聊起来。进程申请内存的时候，会调用 malloc() 和 mmap() 等内存分配函数，最终会发起系统调用陷入内核态进行内存分配。但是，内存分配过程分配的只是虚拟地址空间，并没有给虚拟内存分配对应的物理内存。当进程访问没有建立映射关系的虚拟内存时，将触发一个缺页中断。当一个进程发生缺页中断的时候，进程会再次陷入内核态，查找/分配一个页框，建立映射关系（虚拟地址到物理地址）</p><p>可以看到进程在分配内的时候两次进入内核态，然而两次却完全不同。要理解这一点首先要熟悉两个概念 “进程上下文” vs “中断上下文”</p><p>在 Linux 实现中，处理器在执行过程中总是处于以下三种状态：<br>（1）内核态，运行于进程上下文，内核代表进程运行于内核空间。<br>（2）内核态，运行于中断上下文，内核代表硬件运行于内核空间。<br>（3）用户态，运行于用户空间。</p><p><img src="/images/memory-management-physical-memory/contexts.png" alt="contexts.png"></p><p>内核的地址空间不仅仅要支持硬件访问，同时还需要映射到进程的虚拟地址空间，成为进程上下文的一部分。</p><blockquote><p>当然，单独从实现来看，对于（1）、（2）两种情况，内核的上下文如果完完全全从进程上下文独立开也是可行的，甚至更为简单。但是从性能来看，当前的方案才是更优的。详情参考：<a href="https://www.sciencedirect.com/topics/computer-science/kernel-address-space">《User Space on Top of Kernel Space Versus Separated Address Spaces》</a></p></blockquote><h3 id="分区地址映射"><a href="#分区地址映射" class="headerlink" title="分区地址映射"></a>分区地址映射</h3><p>32位系统中，内核模块的地址空间只有1G。但是，内核又要访问所有的 4G 内存。但内核访问物理内存与进程访问虚拟内存不同，虚实映射既消耗空间也消耗性能（详见：<a href="/12-02-2020/memory-management-summary.html#地址映射">地址映射</a>），且在内核场景下，内存移动与内存换出的需求并不高，也没有多进程隔离的需求（详见：<a href="https://www.cyningsun.com/12-02-2020/memory-management-summary.html#%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB">内存共享</a>），映射的收益不大。</p><p><img src="/images/memory-management-physical-memory/zones.png" alt="zones.png"></p><p>因此，内核把页框分组，划分为不同的区（ZONE）。内核空间的前 896MB（不仅是内核代码，还有它的数据）被“直接”映射到物理内存。虚拟内核空间的最后 128MB 部分被映射到物理“高内存”（&gt; 896MB）的一些部分。物理内存的直接映射允许物理页面分配器的直接访问获得的页面，而无需任何映射操作。获取物理页的虚拟地址所需的唯一操作是添加固定偏移量。</p><p>通过以上方式，既实现 4G 内存的访问，也保证了内核访问的性能。最终，物理内存的页框就被组织成了以下的形式<br><img src="/images/memory-management-physical-memory/physical-memory.png" alt="physical-memory.png"></p><p>从内核地址空间虚实转换的视角来看，如下：<br><img src="/images/memory-management-physical-memory/kernel-address-space.png" alt="kernel-address-space.png"></p><h3 id="内存分配器"><a href="#内存分配器" class="headerlink" title="内存分配器"></a>内存分配器</h3><p>对于空闲内存的分配管理是交给内存分配器进行的。内核中有两种内存分配器，即伙伴系统分配器 和 SLAB 分配器。前者是页框分配器，后者是对象分配器。</p><p>伙伴系统的引入为内核提供了一种用于分配一组连续的页而建立的一种高效的分配策略。避免因频繁地申请和释放不同大小的连续页框，导致在已分配页框的内存块中分散了许多小块的空闲页框，而其他需要分配连续页框的请求无法得到满足。</p><p>SLAB 工作是针对一些经常分配并释放的对象，如进程描述符等内核中常见的小对象。如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内碎片，而且处理速度也太慢。而 SLAB 分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符)，每当要申请这样一个对象，就从一个 SLAB 列表中分配同样大小的内存，而当要释放时，将其重新保存在该列表中。</p><p>伙伴系统解决了内存外部碎片问题，而 SLAB 解决了内存的内部碎片问题。所谓外部碎片是指由于频繁地申请和释放页框而导致的某些小的连续页框，而内部碎片就是指被分配出去但是不能被利用的内存。</p><p><img src="/images/memory-management-physical-memory/memory-allocator.png" alt="memory-allocator.png"></p><p>两个系统的细节暂时按下，后续详聊。</p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/06-15-2021/memory-management-physical-memory.html">https://www.cyningsun.com/06-15-2021/memory-management-physical-memory.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇从我自己的角度来写对物理内存管理的理解。由于 Linux 引入了虚拟内存的概念，应用程序对物理内存的访问都是由内核模块来接管的，因此带着以下问题，逐步揭开相关的细节：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内核是使用什么地址访问物理内存的？&lt;/li&gt;
&lt;li&gt;物理内存为何需要分区？
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.cyningsun.com/category/Linux/"/>
    
    
      <category term="内存管理" scheme="https://www.cyningsun.com/tag/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 设计与查询规范</title>
    <link href="https://www.cyningsun.com/06-06-2021/mysql-design-guide.html"/>
    <id>https://www.cyningsun.com/06-06-2021/mysql-design-guide.html</id>
    <published>2021-06-05T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>想象一下自己是一名伐木工人，手里有林场里最好的斧子，因此你是工作效率最高的。突然有一天场里来了个推销的，他把一种新的砍树工具——链锯——给夸到了天上去。你也买了一把，不过你不懂得怎么用。你估摸着按照自己原来擅长的砍树方法，把链锯大力地挥向树干……</p><p>MySQL 这个工具也是一样，设计规范就是的一个很好的工具说明。即统一了命名风格，又可以让新人快速上手。</p><p>本文的主要内容可以在网上找到类似的版本，但是在一些细节点又略微不同。基于多年 MySQL 使用经验，基于应用与 MySQL 的通盘考虑（视 MySQL 为低配版本的：Bigtable + KV），才有了这些细节上的调整。</p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>避免使用 MySQL 关键词 作为 db / table / field / index 名称</p><ul><li>DB<ul><li>使用项目名作为前缀，“_db” 作为后缀；分库添加后缀8位宽度的数字，数字从0开始</li><li>风格：由下划线分割的小写英文字母组成</li><li>DB 名称总长度小于 42 个字符</li></ul></li><li>Table<ul><li>“_db” 作为后缀；分表添加后缀8位宽度的数字，数字从0开始</li><li>风格：由下划线分割的小写英文字母组成</li><li>表名称总长度小于 48 个字符</li></ul></li><li>Field<ul><li>主键统一定义为：<code>id</code> BIGINT UNSIGNED NOT NULL</li><li>指向其他表主键的字段以 “_id” 后缀结尾</li><li>风格：由下划线分割的小写英文字母组成</li></ul></li><li>Index<ul><li>使用 “idx_” 作为前缀；索引字段名字、顺序组合为名称</li><li>风格：由下划线分割的小写英文字母组成</li></ul></li><li>Comment<ul><li>纯英文单词注释所有字段</li></ul></li></ul><h3 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h3><ul><li>使用 Innodb 存储引擎<blockquote><p>Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好</p></blockquote></li><li>使用 utf8mb4_unicode_ci 编码<blockquote><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效</p></blockquote></li></ul><h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><ul><li><p>使用 utf8mb4_unicode_ci 编码</p></li><li><p>每张表必须显式定义主键</p><blockquote><ol><li>数据的存储顺序和主键的顺序是相同的</li><li>不要使用更新频繁的列作为主键，不要使用 UUID、MD5、HASH、字符串等无法保证数据的顺序增长的字段作为主键</li></ol></blockquote></li><li><p>尽量控制单表数据量的大小，建议控制在 1000万 以内</p><blockquote><ol><li>该量级数据量查询性能较好</li><li>可以用历史数据归档，分库分表等手段来控制单表数据量</li></ol></blockquote></li><li><p>宽表尽量拆分为索引表和内容表以提高查询性能</p><blockquote><ol><li>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节 减少磁盘 IO，保证热数据的内存缓存命中率</li><li>表越宽，装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO，更有效的利用缓存，避免读入无用的冷数据</li></ol></blockquote></li><li><p>谨慎使用 JOIN</p><blockquote><ol><li>应用层缓存效率更高，可以在多种查询场景复用缓存</li><li>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展</li><li>查询效率提升。使用 ID 查询，可以让 MySQL 按照主键索引顺序查询，相比关联要更稳定高效</li></ol></blockquote></li><li><p>谨慎使用 MySQL 分区表</p><blockquote><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表 谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据</p></blockquote></li><li><p>不要使用外键</p><blockquote><ol><li>MySQL 外键实现比较简单粗糙，性能不好</li><li>MySQL 作为后端存储，不在 MySQL 上放置任何计算逻辑</li><li>如果依赖于在 MySQL 服务器上运行的计算逻辑，进行数据库/表分片将非常困难</li></ol></blockquote></li></ul><h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><ul><li><p>优先选择符合存储需要的最小的数据类型</p><blockquote><p>列的字段越大，索引时所需要的空间越大，磁盘单页存储的索引节点数越少，遍历时 IO 次数就越多， 索引性能也就越差</p><p>方法：<br>1）将字符串转换成数字类型存储，如：将IP地址转换成整形数据（inet_aton / inet_ntoa）<br>2）对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储</p></blockquote></li><li><p>存储相同数据的列名和列类型必须一致</p><blockquote><p>如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低</p></blockquote></li><li><p>尽可能把所有列定义为 NOT NULL</p><blockquote><ul><li>NULL 占用额外的空间来保存</li><li>NULL 需要特殊处理，可能会导致应用程序异常</li><li>NULL MySQL 索引统计和值比较更复杂</li></ul></blockquote></li><li><p>避免使用 ENUM 类型</p><blockquote><ul><li>修改 ENUM 值需要使用 ALTER 语句</li><li>ENUM 类型的 ORDER BY 操作效率低，需要额外操作</li><li>禁止使用数值作为 ENUM 的枚举值</li></ul></blockquote></li><li><p>禁止在数据库中存储长文本、图片，文件等大数据</p><blockquote><p>MySQL 内存临时表不支持 TEXT、BLOB 大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行</p><p>而且对于这种数据，MySQL 还是要进行二次查询，会使 SQL 性能变得很差，但是不是说一定不能使用这样的数据类型</p></blockquote></li><li><p>禁止建立预留字段</p><blockquote><ul><li>预留字段的命名很难做到见名识义</li><li>预留字段无法确认存储的数据类型，所以无法选择合适的类型</li><li>对预留字段类型的修改，会对表进行锁定</li></ul></blockquote></li></ul><h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><ul><li>限制每张表上的索引数量，建议单张表索引不超过5个<blockquote><p>MySQL 优化器优化查询时，会根据统计信息，对候选索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能</p></blockquote></li></ul><h3 id="Stored-Programs"><a href="#Stored-Programs" class="headerlink" title="Stored Programs"></a>Stored Programs</h3><ul><li>禁止使用 mysql 视图，存储过程，触发器，自定义函数</li></ul><h3 id="Queries"><a href="#Queries" class="headerlink" title="Queries"></a>Queries</h3><ul><li>禁止直连生产环境，手工删除和修改生产数据</li><li>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询<blockquote><p>可减少表结构变更对应用程序的影响</p></blockquote></li><li>禁止使用不含字段列表的INSERT语句<blockquote><p>正确：INSERT INTO tbl(c1,c2,c3) VALUES (a,b,c);<br>错误：INSERT INTO VALUES (a,b,c);</p></blockquote></li><li>WHERE从句中禁止对列进行函数转换和计算<blockquote><p>对列进行函数转换或计算时会导致无法使用索引。</p><p>正确：WHERE create_time &gt;= 20190101 AND create_time &lt; 20190102<br>错误：WHERE DATE(create_time)=20190101</p></blockquote></li><li>不会有重复值时使用 UNION ALL 而不是 UNION<blockquote><p>UNION 将结果集的所有数据放到临时表后再去重<br>UNION ALL 不会再对结果集进行去重</p></blockquote></li></ul><p>参考链接：<br><a href="https://www.cnblogs.com/huchong/p/10219318.html">https://www.cnblogs.com/huchong/p/10219318.html</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/06-06-2021/mysql-design-guide.html">https://www.cyningsun.com/06-06-2021/mysql-design-guide.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;想象一下自己是一名伐木工人，手里有林场里最好的斧子，因此你是工作效率最高的。突然有一天场里来了个推销的，他把一种新的砍树工具——链锯——给夸
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://www.cyningsun.com/category/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Guide" scheme="https://www.cyningsun.com/tag/Guide/"/>
    
  </entry>
  
  <entry>
    <title>译｜High-Performance Server Architecture</title>
    <link href="https://www.cyningsun.com/06-02-2021/high-performance-server-architecture-cn.html"/>
    <id>https://www.cyningsun.com/06-02-2021/high-performance-server-architecture-cn.html</id>
    <published>2021-06-01T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>本文的目的是分享我多年来关于如何开发某种应用程序的一些想法，对于这种应用程序，术语“服务”只是一个无力的近似称呼。更准确地说，将写的与一大类程序有关，这些程序每秒处理大量离散的消息或请求。网络服务通常最适合此定义，但从某种意义上讲，实际上并非所有的程序都是服务。但是，由于“高性能请求处理程序”是很糟糕的标题，为简单起见，倒不如叫“服务”万事大吉。</p><p>尽管单个程序中多任务处理现在很普遍，但我不会写此类“轻度并行”应用程序。您用来阅读本文的浏览器可能会并行执行某些操作，但是如此低的并行度真的不会带来多少有趣的挑战。当请求处理的基础结构本身是整体性能的瓶颈时，就会出现有趣的挑战，因此改进基础结构实际上会提高性能。对于运行在具有千兆位内存的千兆赫处理器上的浏览器，通过 DSL 线路同时进行六路下载，基础结构成为瓶颈并不常见。此文关注的重点不是用吸管抿水的应用程序，而是从消防水管喝水的应用程序。在硬件功能的边缘，如何做才是真正重要的。</p><p>有些人不可避免地会对我的一些意见和建议持怀疑态度，或者认为他们有更好的方法。挺好，我不是想成为上帝的代言人；我发现这些方法对我来说很有用，不仅是它们对性能的影响，而且它们对以后调试或扩展代码的难度也有影响。效果因人而异。如果还有其他方法对您更好，那太好了，但是请注意，我在这里建议的几乎所有方法都曾作为其他方法的替代品而存在，而我曾经尝试过，只是其结果让人厌恶或恐惧。你最喜欢的想法可能会在其中某个故事中占据显著位置，如果让我现在就讲述出来，无辜的读者可能会无聊至死。您不想伤害他们，对吗？</p><p>本文的其余部分将围绕我称之为“性能糟糕的四骑士”展开：</p><blockquote><p>译者注：天启四骑士，战争、瘟疫、饥荒和死亡。</p></blockquote><ol><li>数据拷贝</li><li>上下文切换</li><li>内存分配</li><li>锁竞争</li></ol><p>最后还将有一个总括的章节，但这些是最大的性能杀手。如果您能够处理大多数请求而无需数据拷贝，无需上下文切换，无需经过内存分配器并且无需竞争锁，那么即使有一些次要问题，您也会拥有一个性能良好的服务。</p><h3 id="数据拷贝"><a href="#数据拷贝" class="headerlink" title="数据拷贝"></a>数据拷贝</h3><p>这可能是一个很短的章节，原因很简单：大多数人已经吸取了这个教训。人人都知道数据拷贝不好。很明显，对吧？实际上，显而易见可能是您在计算机职业生涯的很早就知道，仅仅是因为有人在几十年前就开始使用这个词了。我知道我的情况就是如此，但我离题了。如今，每门学校课程和每个非正式的指南都涵盖了它。甚至营销人员也发现“零拷贝”是一个很好的热门词汇。</p><p>尽管事后看来副本很糟糕，但似乎仍然有些让人错过的细微差别。其中最重要的是，数据拷贝经常是隐藏和伪装起来的。您真的知道您调用的驱动程序或库中的代码是否会进行数据拷贝吗？可能超出您的想象。猜猜PC上的“编程 I/O”是指什么。哈希函数是伪装、非隐藏副本的一个示例，该函数具有副本的所有内存访问开销，并且还涉及更多的计算。一旦指出散列实际上是“拷贝升级版”，显然应该避免使用散列，但我知道至少有一群才华横溢的人，他们必须用艰难的方式来解决这个问题。如果您真的想摆脱数据拷贝，不管是因为它真的会影响性能，还是因为你想把“零拷贝操作”写入黑客会议幻灯片里，您将需要跟踪许多真正属于数据拷贝但并未广而告之的内容。</p><p>避免数据拷贝行之有效的方法是使用间接寻址，并传递缓冲区描述符（或缓冲区描述符链），而不是仅仅使用缓冲区指针。每个描述符通常由以下内容组成：</p><ul><li>整个缓冲区的指针和长度。</li><li>缓冲区的实际填充部分的指针和长度，或偏移量和长度。</li><li>指向列表中其他缓冲区描述符的前后指针。</li><li>引用计数。</li></ul><p>现在，代码只需将适当的缓冲区描述符的引用计数加一，而不用拷贝一段数据以确保它留在内存中。在某些情况下，这种做法可以非常好地工作，包括典型的网络协议栈的运行方式，但也可能成为一个真正令人头痛的问题。一般来说，很容易在链的开始或结尾添加缓冲区，添加对整个缓冲区的引用以及释放整个链。在中间添加，逐块释放或引用部分缓冲区愈加困难。尝试拆分或合并缓冲区简直让人发疯。</p><p>不过，我实际上并不建议所有情况都使用这种方法。为什么不？因为每次要查看头字段时都必须遍历描述符链，这将成为极大的痛苦。确实有比数据拷贝更糟糕的事情。我发现最好的方法是识别程序中的大对象，例如数据块，确保这些大对象按上述方法单独进行分配，这样就不必拷贝它们，也不必过多地操心其他事情。</p><p>这就引出了我关于数据拷贝的最后一点：不要过分规避。我已经看到太多的代码通过做更糟糕的事情来避免数据拷贝，例如强制执行上下文切换或中断大型 I/O 请求。数据拷贝代价很高，当您寻找避免冗余操作的地方时，它是您应首先考虑的问题之一，但是收益递减。对代码进行梳理，然后将其复杂度提高一倍，仅仅是为了去掉最后几份数据副本，通常是在浪费本可以更好利用在其他地方的时间。</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>尽管每个人都认为数据拷贝很糟糕，但我却常常为这么多人完全忽略上下文切换对性能的影响而感到惊讶。根据我的经验，在高负载下，上下文切换实际上比数据副本要落后更多的“崩溃”。系统从一个线程到另一个线程所花费的时间，开始多于它在线程内实际执行有用工作所花费的时间。令人惊奇的是，在某种程度上，导致过度上下文切换的原因是显而易见的。上下文切换的第一大原因是活跃线程数多于处理器数。随着活跃线程与处理器的比率增加，上下文切换的数量也会增加——运气好的话会呈线性关系，但通常呈指数关系。这个非常简单的事实解释了为什么每个连接一个线程的多线程设计的伸缩性非常差。对于可伸缩系统来说，唯一可行的选择是限制活动线程的数量，使其（通常）小于或等于处理器的数量。这种方法的一种流行变体是永远只使用一个线程。尽管这种方法确实避免了上下文抖动，也避免了加锁，它也无法实现超过一个处理器的总吞吐量。因此，除非该程序无论如何都是非 CPU 密集型的（通常是网络I/O密集型的），否则它仍然不受重视。</p><p>“线程有度”的程序要做的第一件事就是弄清楚如何让一个线程同时处理多个连接。这通常意味着前端使用 select/poll、asynchronous I/O、信号或完成端口，后端是事件驱动的结构。哪种前端 API 最好，许多“宗教战争”已经打过，而且还在继续。Dan Kegel 的 <a href="http://www.kegel.com/c10k.html">C10K论文</a><br>是该领域很好的资料。就个人而言，我认为所有 select/poll 和 signal 形式都是丑陋的，因此偏爱 AIO 或完成端口，但实际上并不重要。除了 select()，其他都可以很好地工作，处理程序前端最外层不需要做太多的工作。</p><p>多线程事件驱动服务最简单概念模型是在其中心处有一个队列。一个或多个 “listener” 线程读取请求并将其放入队列，一个或多个 “worker” 线程将其从中移除并处理。从概念上讲，这是一个很好的模型，但是人们通常经常以这种方式实现他们的代码。为什么这样做是错的呢？因为上下文切换的第二大原因是将工作从一个线程转移到另一个线程。有些人甚至要求由原始（译者注：listener）线程发送请求的响应，使错误更严重 —— 导致每个请求需要两次上下文切换而非一次。使用“对称的”方法非常重要，在这种方法中，给定线程可以在不更改上下文的情况下，从 “listener” 成为 “worker”，再成为 “listener”。</p><p>通常，即使将来的一瞬间，也不可能知道有多少个线程处于活跃状态。毕竟，请求可能随时出现在任何连接上，也可能专用于各种维护任务的“后台”线程在那一刻唤醒。如果您不知道有多少线程处于活跃状态，该如何限制有多少活跃线程？以我的经验，最有效也是最简单的方法之一：使用老式的计数信号量，每个线程在执行“实际工作”时都必须持有该信号量。如果已经达到线程限制，则每个 listen 模式线程可能会在唤醒时可能会产生一个额外的上下文切换，然后阻塞在信号量上，但是一旦所有 listen 模式线程都以这种方式阻塞，它们就不会继续争用资源，直到一个现有线程“退出”，因此系统影响可以忽略不计。更重要的是，这种方法处理维护线程比大多数替代方法更优雅（大部分时间处于睡眠状态，因此不计入活跃线程数）。</p><p>一旦将请求处理分为两个阶段（listener 和 worker），并使用多个线程为这些阶段提供服务，就很自然地将处理进一步分为两个以上的阶段。在最简单的形式下，处理一个请求就变成了在一个方向上依次调用各个阶段，然后又在另一个方向上进行调用（对于应答）的问题。但是，事情会变得更加复杂。一个阶段可能代表 “fork”出来两条处理路径的两个互不相同的阶段，或者本身可能会在不调用其他阶段的情况下生成应答（例如，缓存的值）。因此，每个阶段都必须能够指定请求“下一步应该做什么”。由阶段的派发函数的返回值表示，有三种可能：</p><ul><li>该请求需要传递到另一个阶段（返回值中包含指示阶段的ID或指针）。</li><li>请求已完成（特殊的“请求处理完毕”返回值）</li><li>请求被阻塞（特殊的“请求阻塞”返回值）。与前面的情况相同，只是请求没有被释放，稍后将由另一个线程继续执行。</li></ul><p>请注意，在本模型中，请求的排队是在阶段内，而非阶段之间。避免了将请求不断放在后继阶段的队列中，然后立即调用该后继阶段，再次使请求出队的常见愚蠢做法。我称之为没事找事的队列、锁定活动。</p><p>将一个复杂的任务分成多个较小的通信部分的想法似乎很熟悉，那是因为它实际上已经很久远了。我的方法源于 1978 年 C.A.R. Hoare 提出的“<a href="http://www.afm.sbu.ac.uk/csp/">Communicating Sequential Processes</a>”概念，该概念又基于 Per Brinch Hansen 和 Matthew Conway 的思想，这些思想可以追溯到 1963 年 —— 我出生之前！但是，当 Hoare 创造术语 CSP 时，他的意思是抽象数学意义上的“进程”，并且 CSP 进程不必与同名的操作系统实体相关。在我看来，通过单 OS 线程内部类线程的协程以实现 CSP 的常见方法给用户带来了并发的所有麻烦，却又没有任何可伸缩性。</p><p>同一时期，Matt Welsh 的 <a href="http://www.cs.berkeley.edu/~mdw/proj/seda/">SEDA</a> 是一个朝着更明智的方向发展的阶段执行理念的例子。实际上，SEDA 是“正确完成服务架构”的一个很好的例子，它的一些特定的特征值得评论（尤其是那些与我上面概述的特征不同的地方）。</p><ol><li>SEDA 的“批处理”倾向于强调一次处理多个请求，而我的方法倾向于强调一次处理单个请求的多个阶段。</li><li>在我看来，SEDA 的一个显著缺陷是，它为每个阶段分配了一个单独的线程池，只在后台重新分配各个阶段的线程以响应负载。因此，上面提到的引起上下文切换的“1”和“2”原因仍然存在。</li><li>在学术研究项目的背景下，用 Java 实现 SEDA 可能说得通。但是，在现实世界中，这种选择可谓不恰当的。</li></ol><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>分配和释放内存是许多应用程序中最常见的操作之一。因此，人们已经开发出许多巧妙的技巧来使通用存储器分配器更有效。然而，再聪明也弥补不了这样一个事实：在许多情况下，这种分配器的通用性不可避免地使它们的效率远远低于其他分配器。因此，关于如何完全避免使用系统内存分配器，我有三点建议。</p><p>建议一：简单的预分配。我们都知道，静态分配器如果导致程序功能受限，是非常不好的，但是还有许多其他形式的预分配可能会非常有益。通常，原因归结为这样一个事实：即使在此过程中“浪费”了一些内存，通过系统内存分配器的一次访问也要好于几次。因此，如果可以断言同时使用不超过N项，则在程序启动时进行预分配可能是一个有效的选择。即使不是这种情况，也可以在一开始就预先分配请求处理程序可能需要的所有内容，而不是根据需要分配每个内容。除了通过系统分配器在一次行程中连续分配多项的可能性之外，也通常大大简化了错误恢复代码。如果内存非常紧张，那么预分配可能不是一种选择，但在除最极端的情况外的所有情况下，结果通常都是净收益。</p><p>建议二：对经常分配和释放的对象使用 lookaside 列表。基本思想是将最近释放的对象放到列表中，而不是真正释放，希望如果很快再次使用，则只需将其从列表中移除，而不用从系统内存中分配。另一个好处是， lookaside 列表的存取转换的实现通常可以跳过复杂的对象初始化/终结。</p><p>通常不希望 lookaside 列表无限制地增长，即使程序处于空闲状态也从不释放任何内容。因此，通常有必要执行某种定期的 “sweeper” 任务以释放不活跃的对象，但是如果清理程序引入了不适当的加锁复杂性或竞争，则也不可取。因此，一个好的折衷方案是，lookaside 列表实际上由单独加锁的 “old” 列表和 “new” 列表组成的系统。优先从新列表开始分配，然后从旧列表开始分配，并且仅在万不得已的情况下才从系统中分配；对象总是被释放到新列表中。清理线程的操作如下：</p><ol><li>锁定两个列表。</li><li>保存旧列表的表头。</li><li>通过表头赋值，将（以前）新列表变为旧列表。</li><li>解锁。</li><li>在空闲时将保存的旧列表中的所有对象都释放掉。</li></ol><p>此类系统中的对象只有在至少一个但不超过两个完整的清除程序间隔不需要时才真正释放。最重要的是，清除程序在执行大部分工作时没有持有任何与常规线程竞争的锁。理论上，相同的方法可以推广到两级以上，但我还没有发现如此做有用。</p><p>使用 lookaside 列表的一个担心是列表指针可能会增加对象的大小。根据我的经验，使用 lookaside 列表的大多数对象都已经包含了列表指针，所以考虑此点没有实际意义。但是，即使指针只用于 lookaside 列表，但避免使用系统内存分配器（和对象初始化）方面所节省的开销，将远远弥补额外增加的内存。</p><p>建议三：实际上与尚未讨论到的加锁有关，但我仍然要加进来。即使使用 lookaside 列表，锁竞争通常也是分配内存的最大成本。一种解决方案是维护多个私有的 lookaside 列表，这样就绝对不可能争用任何一个列表。例如，每个线程可以有一个单独的 lookaside 列表。出于高速缓存 cache-warmth 的考虑，每个处理器一个列表更好，但是仅在线程无法被抢占的情况下才有效。如有必要，私有 lookaside 列表甚至可以与共享列表相结合，以创建具有极低分配开销的系统。</p><h3 id="锁竞争"><a href="#锁竞争" class="headerlink" title="锁竞争"></a>锁竞争</h3><p>众所周知，高效的加锁方案很难设计，因此我称之为 “Scylla” 和 “Charybdis”，取自《奥德赛》中的怪物。Scylla 是过于简单和/或粗粒度的锁，是可以或应该并行的串行化的活动，这些活动可以或应该并行进行，从而牺牲了性能和可伸缩性。Charybdis 是过于复杂或细粒度的锁，加锁的空间和加锁的操作时间会再次降低性能。靠近 Scylla 的陷阱是代表死锁和活锁的状态。靠近 Charybdis 的陷阱是代表竞态条件。两者之间，有一个狭窄的渠道代表既高效又正确的加锁……或者在哪？由于锁定往往与程序逻辑紧密相关，因此，如果不从根本上改变程序的工作方式，通常就不可能设计出良好的锁定方案。这就是为什么人们讨厌锁，并试图将不可伸缩的单线程实现合理化的原因。</p><p>几乎每个加锁方案都是从“围绕所有事物的一个大锁”开始，并且茫然地希望性能不会太糟。当希望破灭时（几乎总是这样），大锁被分解成小锁，然后继续祈祷，然后重复整个过程，大概直到性能足够为止。但是，通常每次迭代都会增加 20-50％ 的复杂性和锁开销，以减少 5-10％ 的锁竞争。幸运的是，最终结果性能仍然会有些许提高，但实际下降的情况也并不少见。设计师只能挠头了，“我把锁粒度做得更细，就像教科书上说的那样”，他想，“那为什么性能会变得更差呢？”</p><p>我认为情况变得更糟，因为上述方法从根本上讲是错误的。把“解决方案空间”想象成一座山脉，高点代表好的解决方案，低点代表差的解决方案。问题是，“大锁”的起点几乎总是被各种山谷，马鞍山，小山峰、死胡同与高峰隔开。这是一个经典的爬山问题。想从一个起点爬到更高的山峰，只迈出一小步，从不走下坡路，几乎是行不通的。我们需要的是一种完全不同的接近顶峰的方式。</p><p>您要做的第一件事是形成程序加锁的脑中地图。该地图有两个轴：</p><ul><li>纵轴表示代码。如果您使用的是非分支阶段的阶段体系结构，则可能已经有了一个显示划分的图表，就像每个人都在使用的 OSI 模型网络协议栈那样。</li><li>横轴表示数据。在每个阶段中，应将每个请求分配给一个数据集，该数据集使用的资源应该独立于其他任何资源。</li></ul><p>现在有了一个网格，其中每个单元格表示特定处理阶段中的特定数据集。最重要的是以下规则：两个请求不应处于争用状态，除非它们位于相同的数据集和相同的处理阶段。如果你能做到这一点，你已经成功了一半。</p><p>一旦定义了网格，就可以绘制程序的每种加锁类型，下一个目标是确保所得的点尽可能沿两个轴均匀分布。不幸的是，这部分是非常特定于应用的。你必须像钻石切割师一样思考，利用你对程序执行的知识来寻找阶段和数据集之间的自然“解理纹”。它们有时从一开始就很明显，有时很难找到，但回想起来似乎更明显。将代码分为多个阶段是一个复杂的程序设计问题，因此我能提供的内容不多，但以下是一些关于如何定义数据集的建议：</p><ul><li>如果有某种与请求相关联的块号或哈希或事务ID，那么最好将该值除以数据集的数量。</li><li>有时，最好动态地将请求分配给数据集，根据哪个数据集拥有最多的可用资源，而不是请求的某些内在属性。把它想象成现代CPU中的多个整数单元；它们对离散请求流经系统略知一二。</li><li>确保每个阶段的数据集分配不同通常是有用的，这样可以保证在一个阶段竞争的请求在另一阶段不会再次竞争。</li></ul><p>如果您已经将“加锁域”进行了垂直和水平划分，并确保加锁活动均匀地分布在生成的单元格中，则可以确定加锁状态良好。不过，还有一步。您还记得我几段内容之前嘲笑的“小步走”方法吗？它仍然有它的作用，因为现在你处于一个好的起点而不是一个糟糕的起点。用比喻的话来说，你可能已经爬上了这座山脉最高峰之一的斜坡，但你可能还没有到达山顶。现在是时候收集竞争的统计信息了，看看您需要做些什么来改进，以不同的方式拆分阶段和数据集，然后收集更多的统计信息，直到满意为止。如果你做了这些，你一定能从山顶看到美丽的景色。</p><h3 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h3><p>正如我所承诺的，我已经讨论了服务设计中四个最大的性能问题。不过，特定的服务仍然有其他重要的问题需要解决。主要是要了解平台/环境：</p><ul><li>存储子系统如何处理较大和较小的请求？顺序还是随机？read-ahead 和 write-behind 的能力如何？</li><li>使用的网络协议的效率如何？是否可以设置参数或标志以获得更好的性能？是否有诸如TCP_CORK，MSG_PUSH 或 Nagle-toggling 技巧之类的工具可用于避免发送微小消息？</li><li>系统是否支持分散/集中 I/O（例如readv / writev）？使用这些可以提高性能，也可以减轻使用缓冲链的痛苦。</li><li>页大小是多少？缓存行大小是多少？在边界上内容对齐是否值得？相对于其他操作，系统调用或上下文切换的成本多高？</li><li>reader/writer 加锁原语是否处于饥饿？因何饥饿？事件有“惊群效应”的问题吗？睡眠/唤醒是否有一种恶劣的（但非常常见的）行为，即当 X 唤醒 Y 时，即使 X 还有事情要做，上下文也会立即切换到 Y？</li></ul><p>我相信我能想出更多这样的问题。相信你也可以。在任何特定情况下，针对任何一个问题做点什么都不值得，但通常至少值得考虑一下。如果您不知道答案 — 其中许多答案在系统文档中找不到 — 请找出答案。编写一个测试程序或微观基准，从经验上寻找答案；无论如何，编写这样的代码本身就是一种有用的技能。如果您要编写在多个平台上运行的代码，那么其中许多问题都与您应该将功能抽象到每个平台库中的点相关，这样您就可以在支持特定功能的平台上实现性能提升。</p><p>“知道答案”理论也适用于你自己的代码。找出代码中重要的高级操作是什么，并在不同的条件下对它们进行计时。这与传统的概要性能剖析不太一样；这是衡量 <em>设计</em> 元素，而不是实际的实现。低级优化通常是搞砸设计的人最后的选择。</p><p><em>原文：</em> <a href="https://pl.atyp.us/content/tech/servers.html">High-Performance Server Architecture</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/06-02-2021/high-performance-server-architecture-cn.html">https://www.cyningsun.com/06-02-2021/high-performance-server-architecture-cn.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;本文的目的是分享我多年来关于如何开发某种应用程序的一些想法，对于这种应用程序，术语“服务”只是一个无力的近似称呼。更准确地说，将写的与一大类
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Golang channel 的本质</title>
    <link href="https://www.cyningsun.com/05-15-2021/channels-orchestrate-mutexes-serialize.html"/>
    <id>https://www.cyningsun.com/05-15-2021/channels-orchestrate-mutexes-serialize.html</id>
    <published>2021-05-14T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.288Z</updated>
    
    <content type="html"><![CDATA[<p>channel 是 Go 语言独有的一个特性，相比 goroutine 更加抽象，也更加难以理解。毕竟后者可以类比线程、进程。<a href="https://www.jtolio.com/2016/03/go-channels-are-bad-and-you-should-feel-bad/">《Go channels are bad and you should feel bad》</a> 提及在使用 channel 和 mutex 时的困惑。其中提到过一个简单的程序，可以保存一场游戏的各个选手中的最高分。作者分别使用 <code>channel</code> 和 <code>mutex</code> 来实现该功能。</p><h3 id="channel-版"><a href="#channel-版" class="headerlink" title="channel 版"></a>channel 版</h3><p>首先定义 <code>Game</code> 结构体：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Game <span class="hljs-keyword">struct</span> &#123;  bestScore <span class="hljs-keyword">int</span>  scores    <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>&#125;</code></pre><p>bestScore 不会使用 mutex 保护，而是使用一个独立的 goroutine 从 channel 接收数据，然后更新其状态。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Game)</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-keyword">for</span> score := <span class="hljs-keyword">range</span> g.scores &#123;    <span class="hljs-keyword">if</span> g.bestScore &lt; score &#123;      g.bestScore = score    &#125;  &#125;&#125;</code></pre><p>然后定义构造函数来开始一场游戏</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGame</span><span class="hljs-params">()</span> <span class="hljs-params">(g *Game)</span></span> &#123;  g = &amp;Game&#123;    bestScore: <span class="hljs-number">0</span>,    scores:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>),  &#125;  <span class="hljs-keyword">go</span> g.run()  <span class="hljs-keyword">return</span> g&#125;</code></pre><p>紧接着，定义 <code>Player</code> 接口返回该选手的分数，同时返回 error 用以表示 选手放弃比赛等异常情况。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Player <span class="hljs-keyword">interface</span> &#123;  NextScore() (score <span class="hljs-keyword">int</span>, err error)&#125;</code></pre><p>游戏通过 channel 接收所有选手的分数</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Game)</span> <span class="hljs-title">HandlePlayer</span><span class="hljs-params">(p Player)</span> <span class="hljs-title">error</span></span> &#123;  <span class="hljs-keyword">for</span> &#123;    score, err := p.NextScore()    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;      <span class="hljs-keyword">return</span> err    &#125;    g.scores &lt;- score  &#125;&#125;</code></pre><p>最终，<code>Game</code> 得以实现线程安全的记录选手的最高分，一切都很完美。</p><p>该实现大为成功，游戏服务同时创建了很多的游戏。不久，你发现有选手偶尔会停止游戏，很多游戏也不再有选手玩了，但是却没有什么机制停止游戏循环。你正被废弃的  <code>(*Game).run</code> goroutine 压垮。</p><h3 id="mutex-版"><a href="#mutex-版" class="headerlink" title="mutex 版"></a>mutex 版</h3><p>然而，请注意使用 mutex 的解决方案的简单性，它甚至不存在以上问题：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Game <span class="hljs-keyword">struct</span> &#123;  mtx sync.Mutex  bestScore <span class="hljs-keyword">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGame</span><span class="hljs-params">()</span> *<span class="hljs-title">Game</span></span> &#123;  <span class="hljs-keyword">return</span> &amp;Game&#123;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Game)</span> <span class="hljs-title">HandlePlayer</span><span class="hljs-params">(p Player)</span> <span class="hljs-title">error</span></span> &#123;  <span class="hljs-keyword">for</span> &#123;    score, err := p.NextScore()    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;      <span class="hljs-keyword">return</span> err    &#125;    g.mtx.Lock()    <span class="hljs-keyword">if</span> g.bestScore &lt; score &#123;      g.bestScore = score    &#125;    g.mtx.Unlock()  &#125;&#125;</code></pre><h3 id="channel-用以编排，mutex-用以串行"><a href="#channel-用以编排，mutex-用以串行" class="headerlink" title="channel 用以编排，mutex 用以串行"></a>channel 用以编排，mutex 用以串行</h3><p>如果是你来实现，你更愿意使用 <code>channel</code> 还是 <code>mutex</code> ？<br>按照目前提供的信息，毫无疑问，我会选择后者。</p><p>那 channel 和 mutex 有什么区别呢？在什么场景下该使用 channel ？</p><p>其实 <code>Rob Pike</code> 在 <a href="https://go-proverbs.github.io/">Go Proverbs</a> 中总结为：</p><blockquote><p>Channels orchestrate; mutexes serialize.</p></blockquote><p>翻译就是</p><blockquote><p>channel 用以编排，mutex 用以串行</p></blockquote><p>此句话很简单，但也很抽象。究竟该怎样理解呢？</p><h4 id="channel-vs-mutex"><a href="#channel-vs-mutex" class="headerlink" title="channel vs mutex"></a>channel vs mutex</h4><p><code>Rob Pike</code> 在讲述《Concurrency is not Parallelism》中开篇，即提到：</p><ol><li>世界万物是并行的，但是当前的编程语言却是面向对象的</li><li>Golang 希望通过 <code>goroutine</code>（并发执行）、<code>channel</code>（同步和数据传递）、<code>select</code>（多路并发控制）来实现并行</li></ol><p>在之前的文章中，我提到过</p><blockquote><p>对于其他语言的使用者，对于他们而言，程序中的流程控制一般意味着：</p><blockquote><ul><li>if/else</li><li>for loop</li></ul></blockquote><p>在 Go 中，类似的理解仅仅对了一小半。因为 channel 和 select 才是流程控制的重点。<br>channel 提供了强大能力，帮助数据从一个 goroutine 流转到另一个 goroutine。也意味着，channel 对程序的 <strong>数据流</strong> 和 <strong>控制流</strong> 同时存在影响。</p></blockquote><p><code>channel</code> 只是 Go 语言并行化工具集的一部分，其同时肩负了 <strong>数据流</strong> 和 <strong>控制流</strong> 的职责，它是程序结构的组织者。对比来看，<code>mutex</code> 则只关注数据，保障数据串行访问</p><h4 id="编排"><a href="#编排" class="headerlink" title="编排"></a>编排</h4><p>再谈 channel 的编排，可以看下 《Go Concurrency Patterns》中搜索举例：</p><pre><code class="hljs go"><span class="hljs-comment">/*</span><span class="hljs-comment">Example: Google Search 3.0</span><span class="hljs-comment">Given a query, return a page of search results (and some ads).</span><span class="hljs-comment">Send the query to web search, image search, YouTube, Maps, News, etc. then mix the results.</span><span class="hljs-comment">*/</span>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Result)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c &lt;- First(query, Web1, Web2) &#125; ()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c &lt;- First(query, Image1, Image2) &#125; ()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c &lt;- First(query, Video1, Video2) &#125; ()timeout := time.After(<span class="hljs-number">80</span> * time.Millisecond)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;    <span class="hljs-keyword">select</span> &#123;    <span class="hljs-keyword">case</span> result := &lt;-c:        results = <span class="hljs-built_in">append</span>(results, result)    <span class="hljs-keyword">case</span> &lt;-timeout:        fmt.Println(<span class="hljs-string">&quot;timed out&quot;</span>)        <span class="hljs-keyword">return</span>    &#125;&#125;</code></pre><p>无论程序执行在几个核心的机器上，程序的并行结构都没有任何变化，如下：</p><p><img src="/images/channels-orchestrate-mutexes-serialize/orchestrate.png" alt="orchestrate.png"></p><p>讲到程序结构的编排，可以跟服务编排的 Kubernetes 类比。 如果说 goroutine 是 K8S 的容器，channel 就是 K8S 的网络（如，overlay）。Kubernetes 使用户能够以任何规模部署和扩展其微服务应用程序，Golang 使程序能够在任何数量 CPU 的机器上执行和和扩展进行充分的并行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>就像《Concurrency is not Parallelism》说明的那样，目前 channel很大程度的被误用或滥用了。了解清楚 channel 的本质，才能使用正确的工具做对的事。</p><blockquote><p>Goroutines and channels are big ideas. They’re tools for program construction.<br>But sometimes all you need is a reference counter.<br>Go has “sync” and “sync/atomic” packages that provide mutexes, condition variables, etc. They provide tools for smaller problems.<br>Often, these things will work together to solve a bigger problem.<br>Always use the right tool for the job.</p></blockquote><p><em>本文涉及源代码</em> ：<a href="https://github.com/cyningsun/go-test/tree/master/20210509-go-channel-vs-mutex">go-test: 《go-channel-vs-mutex》</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/05-15-2021/channels-orchestrate-mutexes-serialize.html">https://www.cyningsun.com/05-15-2021/channels-orchestrate-mutexes-serialize.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;channel 是 Go 语言独有的一个特性，相比 goroutine 更加抽象，也更加难以理解。毕竟后者可以类比线程、进程。&lt;a href=&quot;https://www.jtolio.com/2016/03/go-channels-are-bad-and-you-should
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Channel" scheme="https://www.cyningsun.com/tag/Channel/"/>
    
  </entry>
  
  <entry>
    <title>译｜My Philosophy On Alerting</title>
    <link href="https://www.cyningsun.com/05-05-2021/my-philosophy-on-alerting-cn.html"/>
    <id>https://www.cyningsun.com/05-05-2021/my-philosophy-on-alerting-cn.html</id>
    <published>2021-05-04T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.288Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于我在谷歌做 SRE（网站可靠性工程师）时的观察</p></blockquote><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>为了值班轮换更加愉快，在审核或编写告警规则时，请考虑以下事项：</p><ul><li>紧急呼叫应该是紧急的、重要的、可操作的、真正的</li><li>应当代表服务正在或即将发生的问题。</li><li>力求消除噪音警报 —— 过度监控比欠监控更难解决。</li><li>问题应该几乎总能分为以下几类：基本功能和可用性、延迟、正确性（数据的完整性、时新性、持久性）、特性相关的问题<blockquote><p>译者注：<br>持久性指的是长期的数据保护，即存储的数据不会受到位衰减、降级或其他损坏。</p></blockquote></li><li>现象是一种更好的方法，可以更轻松，更全面，更可靠地捕获更多问题。</li><li>在基于现象的紧急呼叫或仪表板中包含基于原因的信息，但避免直接就原因告警</li><li>服务栈的上层，一条规则可以发现更多的问题。太上层不能充分区分发生了什么</li><li>安静的值班轮换，需要一个系统处理那些需要及时响应但不紧急的事情</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>七年来，我一直值班各种不同的服务，包括大型和小型、快速变化的产品，以及核心基础设施的几个部分，我已经形成了一种监控和告警的理念。它反映了我对紧急呼叫和传呼机的基本看法：</p><ul><li>每次传呼机响起，我应当<strong>紧急应答</strong>。我每天只能这样做几次，否则会感到疲劳。</li><li>每次紧急呼叫都应该是<strong>可处置的</strong>；简单地记下 “又是这个紧急呼叫” 不是处置。</li><li>每次紧急呼叫都<strong>需要智慧</strong>来处理：没有机械的、可编写脚本的应答。</li></ul><p>总的来说，这有点野心勃勃，但当我在监控系统中编写或评审新的紧急呼叫规则时，它一直指引着我。在我编写或者评审可能产生紧急呼叫的一条新规则时，以下是我使用到的一些问题：</p><ul><li>它是否检测到<strong>未检测到的故障</strong>，即紧急的、可处置的、即将发生或已经发生用户可见的故障。请注意，“N+0” 零冗余的情况被认为是迫在眉睫的，就像您的服务中“即将用完”的部分，比如存储被耗尽。</li><li>确信它是良性的情况，我能<strong>忽略此规则</strong>吗？良性的情况出现在什么时候，为什么出现，可以完善规则来避免这种情况吗？</li><li>它是否显示了一种<strong>肯定（将会）影响用户</strong>的情况？是否有不影响用户检测到的情况应该被排除掉？类似过滤服务器集群内的测试流量。</li><li>针对此警报我可以对<strong>采取行动</strong>吗？行动紧急吗？还是可以等到第二天早上，周末或下个季度？</li><li>是否有其他人同时被积极呼叫？他们会解决这个问题吗？或者我会帮别人解决这个问题？能把这些问题合在一起吗？我的规则能留给他们修改的时间吗？</li></ul><p>下面的想法当然是雄心勃勃的，一个不断增长，不断变化的服务，没有轮值的传呼机是永远安静的。但有一些技巧，让你更接近于此。</p><blockquote><p><strong>术语</strong></p><p>本文使用以下术语：<br><em>紧急呼叫</em> ：任何可以紧急、主动地引起特定人注意的东西（例如，通过寻呼机或手机发出哔哔哔声）<br><em>规则</em> ：在监控系统中检测某些需要关注的情况的逻辑。<br><em>警报</em> ：规则触达人类的一种方式，例如紧急呼叫、电子邮件、聊天室的消息、自动提交的单据等。</p></blockquote><h3 id="围绕用户监控"><a href="#围绕用户监控" class="headerlink" title="围绕用户监控"></a>围绕用户监控</h3><p>我称之为 “基于现象的监控”，而非“基于原因的监控”。用户关心 MySQL 服务器是否停机了吗？不，他们关心查询是否失败(也许你已经开始尴尬了，喜欢 MySQL 服务器的 Nagios 规则？用户甚至不知道 MySQL 服务器存在！）用户是否关心一个重启检测（即非服务路径）脚本是否处于循环中？不，他们只关心自己使用的功能是否失败。他们在乎你的数据推送失败吗？不，他们关心的是能否拿到最新的结果。</p><p>一般来说，用户关心的事情很少：</p><ul><li><strong>基本可用性和正确性</strong>。没有 “Oops!”，没有 5xx ，不挂起的请求或页面加载一半或丢失 Javascript 或 CSS 或图像或视频。任何以某种方式破坏核心服务的行为都应被视为不可用。</li><li><strong>延迟</strong>。快。快。快。还是，快。</li><li><strong>完整性/时新性/持久性</strong>。用户数据应该是安全的，当访问时返回，搜索索引应该是最新的。即使暂时不可用，用户也完全相信数据安全。</li><li><strong>特性</strong>。用户关心服务的所有功能，您应该监视服务所有重要的方面，即使不是核心功能/可用性（例如，搜索结果中显示的计算器和股票行情）。</li></ul><p>差不多了。数据库服务器不可用和用户数据不可用之间存在一个微妙但重要的区别。前者是近因，后者是现象。你不是总能清楚地区分这些东西，特别是当你没有办法模仿客户的视角时（例如，黑盒探测器或直接监控他们的视角）。但当你可以的时候，你应该如此做。</p><h3 id="基于原因的警报不好（但有时是必要的）"><a href="#基于原因的警报不好（但有时是必要的）" class="headerlink" title="基于原因的警报不好（但有时是必要的）"></a>基于原因的警报不好（但有时是必要的）</h3><p>“但是，”你可能会说，“我知道数据库服务器无法访问会导致用户数据不可用。” 可以。告警数据不可用。告警现象：500，Oops！白盒指标，表示并非所有服务器都可以通过数据库的客户端访问。为什么？</p><ul><li><strong>无论如何，你都得抓住现象</strong>。可能是因为网络断开，CPU 竞争，或者其他很多你还没想到的问题。所以你必须抓住现象。</li><li>一旦发现现象和原因，就会有<strong>冗余的警报</strong>；需要单独的调优，并导致重复或复杂的依赖树</li><li><strong>据称不可避免的结果并非总是不可避免的</strong>：数据库服务器不可用，可能是因为您打开了一个新实例或关闭了一个旧实例。或者添加了一个功能来请求的快速故障切换，这样就不再关心单个服务器的可用性了。当然，你可以添加越来越复杂的规则抓住所有这些案例，但为什么麻烦呢？失败模式是太多的虚假紧急呼叫，太多的混乱，太多的调整，没有任何收获，修复重要的警报的时间更少。</li></ul><p>但有时它们是必要的。“几乎”用完配额、内存或磁盘 I/O 等等（通常）没有任何现象，所以您需要规则知道您正在走向悬崖。<strong>慎用；不要为可能出现的现象编写基于原因的紧急呼叫规则。</strong></p><h4 id="在出口（或调用侧）告警"><a href="#在出口（或调用侧）告警" class="headerlink" title="在出口（或调用侧）告警"></a>在出口（或调用侧）告警</h4><p>分层客户端/服务器架构系统中，警报最好来自客户端的判断：</p><ul><li><strong>客户端可以看到重试的结果、客户端和服务器之间的网络延迟</strong>，并且对用户面临的延迟和错误比服务器有更好的判断</li><li>在许多情况下，客户端（如，混合或应用程序服务器）正在<strong>聚合来自许多后端的响应</strong>，如缓存服务、数据库、帐户管理/授权服务、查询分片等。如果您<strong>看到客户端实际执行的操作</strong>，那么您的监控更为健壮的应对底层基础结构（以及应用程序级故障切换和重试）中的变更。</li><li>在许多情况下，客户端可以提供比后端更简单的整体视图。例如，如果一个请求分散到数百个查询服务器上，那么每个查询服务器的整体视图都非常有限，无法成为有用的告警源。</li></ul><p>对于许多服务，意味着基于最前端的负载平衡器看到的延迟、错误等方面的情况告警。如此，只有当服务器损坏的结果向用户显示时，您才能看到告警。反之，实际的问题比从服务器上看到的问题更大：如果服务器全部停机，或者返回无数的 5xx，或者 10% 的连接断开，负载均衡器知道，但服务器可能不知道。</p><p>请注意，如果做得太过头，可能会引入超出您控制和责任范围的代理。如果你能可靠地捕捉到用户所看到的（例如通过浏览器侧的设施）的观点，那太好了！但请记住，这些信号充满了噪音，包括ISP、浏览器、客户端负载和性能，所以这不应该是你看待世界的唯一方式。如果您的外部监控无法始终通畅，它可能是有损的。即使遇到这种极端情况，仍然是一个有用的信息，但可能不是一个你想要用来紧急呼叫的信息。</p><h4 id="原因仍然有用"><a href="#原因仍然有用" class="headerlink" title="原因仍然有用"></a>原因仍然有用</h4><p>基于原因的规则仍然有用。特别是，它们可以帮助您快速跳转到生产系统中已知的缺陷。</p><p>如果你在自动将现象与原因联系起来方面得到了很多值，也许是因为有些原因超出了你的控制范围，需要消除，我支持以下方法：</p><ol><li>当您编写（或发现）表示原因的规则时，请检查是否也捕获了现象。如果没有，添加现象的规则进来。</li><li>为所有原因的告警触发的紧急呼叫，输出一份简短的摘要。快速浏览一下，就可以确被紧急呼叫的现象是否有已经确定的原因。类似： <pre><code class="hljs bash">TooMany500StatusCodesServed 10.7% 5xx results <span class="hljs-keyword">in</span> the last 3 minutes!Also firing:    JanitorProcessNotKeepingUp    UserDatabaseShardDown    FreshnessIndexBehind</code></pre> 此情况，很明显 5xx 最可能的来源是数据库问题；相反，如果触发现象是磁盘已满，或者结果页变空或过时，那么其他两个原因可能值得关注。</li><li>删除或调整有噪声、持续性、或低价值的基于原因的规则。</li></ol><p>使用以上方法，错误的、嘈杂的规则所带来的精神负担已经从传呼机的哔哔声（以及调查、跟进和……）变成了要浏览的一行文字。最后，由于您无论如何都需要清晰的调试仪表板（对于不是以警报开始的问题），因此这是公开基于原因的规则的另一个好地方。</p><p>也就是说，如果您的调试仪表板让您能够足够快地从现象到原因再到改善，那么您不需要花费时间在基于原因的规则上。</p><h3 id="单据、报告及电子邮件"><a href="#单据、报告及电子邮件" class="headerlink" title="单据、报告及电子邮件"></a>单据、报告及电子邮件</h3><p>不管怎样，你有一些警报需要以后注意，但不是现在。我称之为“次关键告警”。</p><ul><li><strong>Bug 或单据跟踪系统很有用</strong>。只要同一个警报的多次触发被正确地线程化到一个 ticket/bug，让告警创建 bug 单据效果会很好。如果没有对分类和关闭 bug 负责，系统就会失败；作为一种在次关键警报变为警报之前处理次关键警报的方法，如果警报创建的 bug 可能会在数周内不可见，显然是一种失败的处理方法！如果你的团队超负荷工作或者没有指派足够的人员来处理后续工作，那么也会失败；你需要诚实地知道这需要花费多少时间，否则你会越来越落后。</li><li><strong>每日（或更频繁）的报告也可以起作用</strong>。一种可行的方法是编写长期存在的次关键规则（例如，“数据库容量超过 90%”或“昨日慢速请求数超过 1000 个”），并定期发送一份报告，显示当前所有触发规则。同样，如果没有一个问责系统，会变成略微垃圾的邮件警报，所以确保值班人员（或其他人）被指定每天（或每班交接，或任何有效的方法）对这些邮件进行分类。</li><li>通过工作流系统跟踪每个警报。不要只将它们转储到电子邮件列表或在线聊天室频道。一般来说，会很快变成专门的“foo警报”邮件列表或频道，因此可能会被轻易忽略。除非存在一个简短的（通常是几天，最多是几周）时间来审查一个新规则保证不会太频繁的紧急呼叫，这几乎总是一个坏主意。这样做也很容易忽略这些警报的数量，突然，数千个应用服务器每分钟都会触发一些旧的，调整不当的规则，从而阻塞邮箱。</li></ul><p>根本要点是创建一个系统，该系统仍然对响应性负责，但不唤醒某人，打断他们的晚餐或防止阻碍其与另一半相互依偎</p><h3 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h3><p>手册（或运行手册）是告警系统的重要组成部分。最好每个捕捉到的现象的警报或系列警报都有一个条目，它可以进一步解释警报的含义以及如何处理该警报。</p><p>一般来说，如果首层有一个详细的流程图，<strong>你可能会花太多的时间去记录可能错误的信息，而花太少的时间去修复它</strong>，除非根本原因完全超出你的控制或者根本上需要人为干预（比如，打电话给供应商）。我见过的最好的手册中有关于警报的确切含义的注释，以及警报目前的关注点（“VendorX的小部件已经有一系列断电；如果出现该问题，请将它添加到 Bug12345，我们正在那里跟踪问题出现的模式“）大多数此类注释应该都是临时的，因此 Wiki 或类似的东西会是一个不错的工具。</p><h3 id="跟踪和责任"><a href="#跟踪和责任" class="headerlink" title="跟踪和责任"></a>跟踪和责任</h3><p>跟踪您的紧急呼叫和所有其他告警。如果一个紧急呼叫正在运行，而人们只是说“我看了，没什么不对劲”，这是一个非常强烈的信号，表明您需要删除紧急呼叫规则，或者将其降级，或者以其他方式收集数据。准确率低于50%的警报是已经破坏的；即使那些 10% 的误报的也值得更多的考虑。</p><p>一个适当的系统（例如，<strong>每周对所有紧急呼叫进行一次审查，每季度进行一次统计</strong>）有助于掌握大局，并梳理出传呼机从一个人传递到下一个人时丢失的模式。</p><h3 id="你太天真了"><a href="#你太天真了" class="headerlink" title="你太天真了"></a>你太天真了</h3><p>是的，不过我更喜欢“野心勃勃”这个词。以下是打破上述准则的一些重要原因：</p><ul><li><strong>有一个已知的原因实际上位于现象的噪音之下</strong>。例如，如果您的服务有 99.99% 的可用性，但是有一个导致 0.001% 的请求失败的常见事件，那么您不能将其作为现象进行警报（因为它处于噪音中），但您可以捕获导致的事件。也许值得一试，把这些信息添加到栈上，但也许仅仅提醒原因是最简单的。警告值班人员。</li><li><strong>您无法监控出口，因为丢失了数据分辨率</strong>。 例如，也许您可以容忍某些 handlers/endpoints/backends/URLs 相当慢（例如，验证信用卡与浏览待售商品相比）或可用性低（例如，收件箱的后台刷新）。 在负载均衡器上，这种区分可能会丢失。 从栈中走下来，并从有区分的最高位置发出警报。</li><li><strong>现象出现时已经太晚，就像已经用完配额</strong>。当然，您需要在太迟之前紧急呼叫，有时这意味着要找到紧急呼叫的原因（例如，使用率 &gt;80%，并将在 &lt;4 小时内以最后 1 小时的增长率用完）。但如果你能做到这一点，你也应该能够找到一个类似的原因，不那么紧迫（例如配额 &gt;90%，并将在 &lt;4d 以过去 1d 的增长率耗尽），这将抓住大多数情况，并处理作为一张单据或电子邮件警报或每日问题报告，而不是最后的升级，一个紧急呼叫所代表的。</li><li><strong>警报设置听起来比试图检测的问题更复杂</strong>。有时如此。目标应该是趋向于简单、健壮、自我保护的系统（你怎么没有注意到配额已经用完了？为什么这些数据不能转移到其他地方？）从长远来看，它们应该趋向于简单化，但在任何给定的时间，局部最优可能是相对复杂的规则，以保持安静和准确。</li></ul><p><em>原文：</em> <a href="https://docs.google.com/document/d/199PqyG3UsyXlwieHaqbGiWVa8eMWi8zzAn0YfcApr8Q/edit#heading=h.f2j0epxtq9mi">My Philosophy On Alerting</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/05-05-2021/my-philosophy-on-alerting-cn.html">https://www.cyningsun.com/05-05-2021/my-philosophy-on-alerting-cn.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基于我在谷歌做 SRE（网站可靠性工程师）时的观察&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;为了值班轮换更加愉快
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>内容型产品架构：推模型还是拉模型？</title>
    <link href="https://www.cyningsun.com/04-19-2021/content-products-push-or-pull.html"/>
    <id>https://www.cyningsun.com/04-19-2021/content-products-push-or-pull.html</id>
    <published>2021-04-18T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.288Z</updated>
    
    <content type="html"><![CDATA[<p>无论是信息流、论坛、信箱，还是私聊、群聊、通知，推拉模型是内容型（包括：社交型）产品架构的核心。做出正确选择的关键在于对 产品形态 和系统组件 清晰的认识</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p><img src="/images/content-products-push-or-pull/push-or-pull.jpg" alt="push vs pull"></p><h4 id="推模型（写扩散）"><a href="#推模型（写扩散）" class="headerlink" title="推模型（写扩散）"></a>推模型（写扩散）</h4><p>为每个内容消费者维护订阅列表，记录订阅的内容索引（一般为内容ID、类型、发表时间等索引数据）。每当内容生产者发布内容时，都会写入所有内容消费者的订阅列表。</p><ul><li>优点：读很轻。仅需要读取订阅列表即可。</li><li>缺点：写很重。内容生产者每发布一条内容，会导致大量的写操作。</li></ul><h4 id="拉模型（读扩散）"><a href="#拉模型（读扩散）" class="headerlink" title="拉模型（读扩散）"></a>拉模型（读扩散）</h4><p>为每个内容生产者维护一个内容列表，记录该用户所有生产的内容索引。</p><ul><li>优点：写很轻，节省空间。内容生产者每发布一条内容，仅需写入自己的内容列表。</li><li>缺点：读很重，计算量大。假设内容消费者订阅了 1k 个生产者，则每次读取都需要从 1k 个生产者的内容列表拉取内容，以获得最新的 n 条内容。</li></ul><h3 id="产品形态"><a href="#产品形态" class="headerlink" title="产品形态"></a>产品形态</h3><table><thead><tr><th>产品形态</th><th>粉丝数量上限</th><th>时间线</th><th>排序方式</th></tr></thead><tbody><tr><td>微博</td><td>无</td><td>秒～分</td><td>时间</td></tr><tr><td>短视频推荐，例如 TikTok</td><td>无</td><td>秒～分</td><td>推荐</td></tr><tr><td>社交分享，例如 微信朋友圈</td><td>5000</td><td>秒级</td><td>时间</td></tr><tr><td>私信，例如 微信聊天</td><td>1</td><td>秒级</td><td>时间</td></tr></tbody></table><p>所有该类型的产品，都有三个核心的角色：内容生产者、内容、内容消费者。后台系统要做的事情就是保障内容从内容生产者快速、可靠的分发给内容消费者。系统架构的难点在于：</p><ol><li>将一条内容投递给一个消费者，还是投递给亿级的消费者（例如，微博、抖音）</li><li>投递数条内容，还是投递数亿条内容（例如，微信群聊）</li></ol><p>产品形态不同，会放大一些技术方案的缺点，最终导致难以扩展或者成本难以接受。对于推模型</p><ul><li>订阅上限过高，则会放大写扩散的问题</li><li>内容顺序不确定，写扩散同样毫无意义</li></ul><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><p>内容生成之后要首先通过写入落地到存储系统中，然后当内容消费者需要的时候再读取出来。不同的存储系统使用了不同的存储模型，首先看下常见的存储模型：</p><ul><li>B-tree：读取友好，数据有序。LIRS算法，将缓冲池分为两级，数据首先进入第一级，如果数据在较短的时间内被访问两次或者以上，则成为热点数据进入第二级，每一级内部还是采用LRU替换算法。例如：关系型数据库</li><li>Bitcask：写入友好，数据无序。在内存中存储了主键和value的索引信息，磁盘文件中存储了主键和value的实际内容。需要定期执行合并（Compaction）操作以实现垃圾回收。Bitcask通过索引文件（hint file）来提高重建哈希表的速度。例如：Beandb</li><li>LSM：写入友好，数据有序。将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘，读取时需要合并磁盘中的历史数据和内存中最近的修改操作，需要定期执行合并（Compaction）操作以实现垃圾回收。例如：LevelDB、RocksDB、Bigtable</li></ul><p>回过头再看推模型和拉模型，两者对读写性能的要求大不相同：</p><table><thead><tr><th>类型</th><th>推模型</th><th>拉模型</th><th>推-拉模型</th></tr></thead><tbody><tr><td>读延迟</td><td>毫秒</td><td>秒</td><td>秒</td></tr><tr><td>读写比</td><td>1:99</td><td>99:1</td><td>50:50</td></tr><tr><td>系统要求</td><td>健壮的写入能力</td><td>健壮的读取能力</td><td>平衡的读写能力</td></tr><tr><td>常见系统</td><td>采用 LSM 架构的分布式 NoSQL，如 Bigtable</td><td>缓存系统如 Redis 和 Memcached 或 搜索系统（推荐场景）</td><td>两者结合</td></tr><tr><td>架构复杂度</td><td>简单</td><td>复杂</td><td>更复杂</td></tr></tbody></table><p>除此之外，由于数据量快速增涨，内容存储还需要方便进行快速的扩容，而不同的存储系统对扩展性的支持存在较大的差异：</p><table><thead><tr><th>特点</th><th>分布式 NoSQL</th><th>关系数据库  (分库/分表)</th></tr></thead><tbody><tr><td>扩展性</td><td>线性</td><td>需要重构</td></tr><tr><td>扩展速度</td><td>毫秒</td><td>N/A</td></tr><tr><td>常见系统</td><td>Table Store、Bigtable</td><td>MySQL</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>选择推模型还是拉模型，需要考虑产品特征，以及存储系统。放眼业界</p><p>微信朋友圈使用写扩散：</p><blockquote><ul><li>产品层面：订阅者最多只有5000 （最多 5000 好友）</li><li>存储层面：分布式 NoSQL <a href="https://github.com/davideuler/architecture.wechat-tencent/blob/master/Qcon_201405_%E5%BE%AE%E4%BF%A1%E5%90%8E%E5%8F%B0%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84_%E8%AE%B8%E5%AE%B6%E6%BB%94.pdf">QuorumKV</a>、<a href="https://www.infoq.cn/article/one-billion-paxos-minutes-of-challenge">PaxosStore</a></li></ul></blockquote><p>微博使用读扩散：</p><blockquote><ul><li>产品层面：订阅数没有上限</li><li>存储层面：<a href="https://www.slideshare.net/iso1600/high-performance-weibo-qcon-beijing-2011-7577912">Redis + MySQL</a></li></ul></blockquote><p>推特</p><blockquote><ul><li>产品层面：订阅数没有上限</li><li>存储层面：MySQL + Redis，中间一度迁移到 Cassandra，最后又回来。(<a href="https://blog.twitter.com/engineering/en_us/a/2010/cassandra-at-twitter-today.html">《Cassandra at Twitter Today》</a>)</li></ul></blockquote><p>最终，微信很多时间都花费到在了写扩散带来的成本问题；微博很多时间都在应对关系型数据库导致的扩展性问题，以及读扩散导致的”挂了又挂”。Twitter 很多时间都在“纠结”，前期使用写扩散，最后不得不结合读扩散，拥抱 Nosql 最终又回到 MySQL。</p><p>推拉模型对于互联网产品的影响至此，重要程度可见一斑</p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/04-19-2021/content-products-push-or-pull.html">https://www.cyningsun.com/04-19-2021/content-products-push-or-pull.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无论是信息流、论坛、信箱，还是私聊、群聊、通知，推拉模型是内容型（包括：社交型）产品架构的核心。做出正确选择的关键在于对 产品形态 和系统组件 清晰的认识&lt;/p&gt;
&lt;h3 id=&quot;模型&quot;&gt;&lt;a href=&quot;#模型&quot; class=&quot;headerlink&quot; title=&quot;模型&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何维护好一个微服务</title>
    <link href="https://www.cyningsun.com/03-31-2021/how-maintain-a-micro-service.html"/>
    <id>https://www.cyningsun.com/03-31-2021/how-maintain-a-micro-service.html</id>
    <published>2021-03-30T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.288Z</updated>
    
    <content type="html"><![CDATA[<p>微服务火了这么久，服务越拆越多，但是很少有人知道如何维护好一个微服务。本文以微博的 “用户资料” 服务举例来谈谈。</p><p>显而易见，一个正常状态的 “用户资料” 服务应该呈现以下状态：</p><ol><li><p>调用量以用户资料相关接口为主</p><blockquote><p>举例：<br>调整前：为了保证用户已登记该设备，每次打开设备都调用 “用户资料” 的“登记设备”的接口。登记设备 占据该模块很大一部分请求量。<br>调整后：客户端修改逻辑，已经登记成功的设备落地存储，停止重复调用。</p></blockquote></li><li><p>调用量应该读多写少（服务特性相关）</p><blockquote><p>举例：<br>调整前：<br>重复登记导致，用户资料表一直变化</p><p>调整后：<br>用户资料几乎固定不变，<a href="/08-18-2020/first-lesson-of-database.html#%E5%AD%98%E5%82%A8%E7%BB%86%E5%88%86">读多写少的存储选型</a>能够更好的发挥作用</p></blockquote></li><li><p>调用量高的接口耗时最低、最简单</p><blockquote><p>举例：<br>微信早期限制 5000 好友的主要原因是朋友圈采用类似邮箱 “写扩散” 模 型。</p><ul><li>发朋友圈较少：群发需要先读取关系链，较为复杂</li><li>刷朋友圈较多：读取收件箱较为简单</li></ul></blockquote></li><li><p>依赖清晰、干净，层次符合预期</p><blockquote><p>举例：<br>以公众号的 “打赏” 功能为例，假如该功能也放在 “用户资料服务” 中。用户因为某一篇文章打赏作者<br>在用户资料中调用 “文章服务” 的接口验证打赏是不合理的。因为通常来说都是 “文章服务” 服务 依赖 “用户资料服务”</p></blockquote></li><li><p>接口的目的主要是提供服务，绝大部分调用应该正确返回，而非返回错误信息</p><blockquote><p>举例：<br>很多需要权限的操作，前端/客户端完全有能力直接拦截跳转，但很多却依靠后端拦截跳转，导致接口中存在相当一部分无效的请求。错误浪费了用户的时间和服务的资源。</p></blockquote></li><li><p>服务耗时、调用量、错误不应当出现猛增突降、毛刺</p><blockquote><p>举例：<br>在需求发布后</p><ul><li>接口耗时下降：意味着该接口执行的代码变少了，或者逻辑变简单了。耗时异常下降，可能意味着发布存在缺陷、</li><li>接口调用量突然上涨：可能意味着业务逻辑出错，用户在不断重试。</li></ul></blockquote></li><li><p>错误应该是明确的</p><blockquote><p>举例：<br>用户更新资料的时候，明确提示用户参数 “内容存在敏感信息”，好过于提示用户 “参数错误”<br>越明确的错误，越能判定业务是否存在可以改进的点</p></blockquote></li></ol><p>反之，则意味着该服务存在问题，需要修正。</p><ul><li>不符合 1、2、3、4 点，意味着该服务设计存在问题，性能不佳，无法承担该服务应该承担的职责；</li><li>不符合 4、5、6 点，意味着存在潜在的问题，或者当出现问题时无法得到有效识别。</li></ul><p>维护好一个服务，不要匆忙下结论(Don’t rush to conclusion)。保持对业务细节的认识，保持对数据、事实的敏感和开放。</p><blockquote><p>事例：</p><ul><li>Round A: 某日中午平台的用户下线较多，服务出现部分告警。服务维护者周知因为…所以服务正常</li><li>Round B: 缺少数据依据</li><li>Round C: 了解文化发现：当地该时间点 男性要下线做礼拜；分析下线总数、性别比率与预期一致</li><li>Round D: 获得知识：业务促销应该避开该时间段…</li></ul></blockquote><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/03-31-2021/how-maintain-a-micro-service.html">https://www.cyningsun.com/03-31-2021/how-maintain-a-micro-service.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;微服务火了这么久，服务越拆越多，但是很少有人知道如何维护好一个微服务。本文以微博的 “用户资料” 服务举例来谈谈。&lt;/p&gt;
&lt;p&gt;显而易见，一个正常状态的 “用户资料” 服务应该呈现以下状态：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;调用量以用户资料相关接口为主&lt;/p&gt;
&lt;bloc
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Golang 面向对象编程</title>
    <link href="https://www.cyningsun.com/03-12-2021/oop-in-go.html"/>
    <id>https://www.cyningsun.com/03-12-2021/oop-in-go.html</id>
    <published>2021-03-11T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Golang-是面向对象的么？"><a href="#Golang-是面向对象的么？" class="headerlink" title="Golang 是面向对象的么？"></a>Golang 是面向对象的么？</h3><p>是，也不是。尽管 Go 有类型和方法，并且允许面向对象风格的编程，但没有类型层次结构。Go 的『接口』概念提供了一种不同的实现方式，在某些方面更通用。同时，缺少类型层次结构使 Go 的『对象』感觉上比 C++ 或 Java 等语言中的『对象』轻很多。本文的目的就是通过示例来说明，如何使用 Golang 进行面向对象编程</p><h3 id="过程化"><a href="#过程化" class="headerlink" title="过程化"></a>过程化</h3><p>以下是一个关于身份证ID的示例，用于从身份证中提取生日。通常的实现版本如下：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Birthday</span><span class="hljs-params">(id <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> id[<span class="hljs-number">6</span>:<span class="hljs-number">14</span>]&#125;</code></pre><pre><code class="hljs go"><span class="hljs-keyword">const</span> (id = <span class="hljs-string">&quot;412717199109031697&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_Birthday</span><span class="hljs-params">(t *testing.T)</span></span> &#123;found := Birthday(id)wanted := <span class="hljs-string">&quot;19910903&quot;</span><span class="hljs-keyword">if</span> found != wanted &#123;t.Errorf(<span class="hljs-string">&quot;unexpected birthday, wanted:%v, found:%v&quot;</span>, wanted, found)&#125;&#125;</code></pre><p>简单的数据，如此实现倒也问题不大。但生产环境中往往遇到的都是复杂的多的数据和操作。此时就需要将数据和操作封装在一起</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>Golang 中可以通过 <code>type</code> 关键字创建新的类型，同时使用 <code>NewXXX</code> 的风格创建对象。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> ID <span class="hljs-keyword">string</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewID</span><span class="hljs-params">(id <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(ID, error)</span></span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(id) != <span class="hljs-number">18</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, errors.New(fmt.Sprintf(<span class="hljs-string">&quot;error id length:%v&quot;</span>, <span class="hljs-built_in">len</span>(id)))&#125;<span class="hljs-keyword">return</span> ID(id), <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i ID)</span> <span class="hljs-title">Birthday</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(i[<span class="hljs-number">6</span>:<span class="hljs-number">14</span>])&#125;</code></pre><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestID_Birthday</span><span class="hljs-params">(t *testing.T)</span></span> &#123;found := ID(id).Birthday()wanted := <span class="hljs-string">&quot;19910903&quot;</span><span class="hljs-keyword">if</span> found != wanted &#123;t.Errorf(<span class="hljs-string">&quot;unexpected birthday, wanted:%v, found:%v&quot;</span>, wanted, found)&#125;&#125;</code></pre><p>当业务变得更加复杂，同一种功能，存在多种实现方式，比如支付方式，微信支付、京东支付、支付宝、银联等不同渠道的大概流程大抵相似，但实现细节有所区别。此时就需要借助多态的动态绑定来进行业务抽象。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Golang 中动态绑定方法的唯一方式是通过接口（interface）来实现的。结构或其他具体类型上的方法始终是静态的。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> ID <span class="hljs-keyword">interface</span> &#123;Birthday() <span class="hljs-keyword">string</span>&#125;<span class="hljs-keyword">type</span> id <span class="hljs-keyword">string</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewID</span><span class="hljs-params">(i <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(ID, error)</span></span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(i) != <span class="hljs-number">18</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(fmt.Sprintf(<span class="hljs-string">&quot;error id length:%v&quot;</span>, <span class="hljs-built_in">len</span>(i)))&#125;<span class="hljs-keyword">return</span> id(i), <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i id)</span> <span class="hljs-title">Birthday</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(i[<span class="hljs-number">6</span>:<span class="hljs-number">14</span>])&#125;</code></pre><pre><code class="hljs go"><span class="hljs-keyword">const</span> (fakeid = <span class="hljs-string">&quot;412717199109031697&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestID_Birthday</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> i IDi, _ = NewID(fakeid)found := i.Birthday()wanted := <span class="hljs-string">&quot;19910903&quot;</span><span class="hljs-keyword">if</span> found != wanted &#123;t.Errorf(<span class="hljs-string">&quot;unexpected birthday, wanted:%v, found:%v&quot;</span>, wanted, found)&#125;&#125;</code></pre><p>除了线性的业务逻辑处理场景，在生产中还会遇到层状的业务流，但是不同层次之间又有很多功能是相通的，此时就需要借助“继承”之类的能力，来实现代码复用。遗憾的是 Golang 中并不存在继承，下面我们介绍它的替代者</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>在最知名的语言中，面向对象编程很多讨论是关于类型之间关系的。Go 采用了不同的实现 —— 隐藏类式的类型依赖。</p><p>在 Go 中，类型会自动满足指定其方法子集的任何接口，无需提前声明两种类型相关联。类型可以一次满足许多接口，而没有传统的多重继承的复杂性。 类型和接口之间没有明确的关系，所以不涉及类型层次结构。类似想法可以用来构造像类型安全的 Unix 管道一样的实现。</p><p>所有的“继承”之类的实现，在 Golang 中都能以组合（或内嵌）的方式来实现，组合和内嵌的对象可以是具体的类型，也可以抽象的接口。以下示例介绍了两种风格的实现：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Man <span class="hljs-keyword">interface</span> &#123;Birthday() <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMan</span><span class="hljs-params">(name, id <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(Man, error)</span></span> &#123;i, err := NewID(id)<span class="hljs-keyword">return</span> &amp;man&#123;id:   i,name: name,&#125;, err&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewManEmbedding</span><span class="hljs-params">(name, id <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(Man, error)</span></span> &#123;i, err := NewID(id)<span class="hljs-keyword">return</span> &amp;manEmbedding&#123;ID:   i,name: name,&#125;, err&#125;<span class="hljs-keyword">type</span> man <span class="hljs-keyword">struct</span> &#123;id   IDname <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *man)</span> <span class="hljs-title">Birthday</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> m.id.Birthday()&#125;<span class="hljs-keyword">type</span> manEmbedding <span class="hljs-keyword">struct</span> &#123;IDname <span class="hljs-keyword">string</span>&#125;</code></pre><pre><code class="hljs go"><span class="hljs-keyword">const</span> (peterid = <span class="hljs-string">&quot;412717199109031697&quot;</span>samid   = <span class="hljs-string">&quot;312717199109036148&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMan_Birthday</span><span class="hljs-params">(t *testing.T)</span></span> &#123;peter, _ := NewMan(<span class="hljs-string">&quot;peter&quot;</span>, peterid)sam, _ := NewMan(<span class="hljs-string">&quot;sam&quot;</span>, samid)mans := []Man&#123;peter, sam&#125;<span class="hljs-keyword">for</span> _, man := <span class="hljs-keyword">range</span> mans &#123;found := man.Birthday()wanted := <span class="hljs-string">&quot;19910903&quot;</span><span class="hljs-keyword">if</span> found != wanted &#123;t.Errorf(<span class="hljs-string">&quot;unexpected birthday, wanted:%v, found:%v&quot;</span>, wanted, found)&#125;&#125;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Write go in go way. Golang 很多经典的思想都可以通过官方文档获得，例如：<a href="https://golang.org/doc/faq">FAQ</a>。</p><p><em>源代码：</em><a href="https://github.com/cyningsun/go-test/tree/master/20210311-oop-in-go">https://github.com/cyningsun/go-test/tree/master/20210311-oop-in-go</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/03-12-2021/oop-in-go.html">https://www.cyningsun.com/03-12-2021/oop-in-go.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Golang-是面向对象的么？&quot;&gt;&lt;a href=&quot;#Golang-是面向对象的么？&quot; class=&quot;headerlink&quot; title=&quot;Golang 是面向对象的么？&quot;&gt;&lt;/a&gt;Golang 是面向对象的么？&lt;/h3&gt;&lt;p&gt;是，也不是。尽管 Go 有类型和方法
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="OOP" scheme="https://www.cyningsun.com/tag/OOP/"/>
    
  </entry>
  
  <entry>
    <title>译 | Packages as layers, not groups</title>
    <link href="https://www.cyningsun.com/03-03-2021/packages-as-layers-not-groups-cn.html"/>
    <id>https://www.cyningsun.com/03-03-2021/packages-as-layers-not-groups-cn.html</id>
    <published>2021-03-02T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.287Z</updated>
    
    <content type="html"><![CDATA[<p>四年前，我写了一篇名为 <a href="https://www.gobeyond.dev/standard-package-layout/">《标准包布局》</a> 的文章试图阐述：包布局。即使对高级 Go 开发人员来说，这也是最困难的话题之一。然而，大多数开发人员还在艰难地将代码组织到目录结构中，相应的目录结构随着应用程序缓慢增长。</p><p>几乎所有编程语言都有一种机制，将相关功能组合在一起。Ruby 有 <code>gems</code>，Java 有 <code>package</code>。这些语言没有约定代码进行分组的标准，因为的确并不重要。最终一切都取决于个人喜好。</p><p>然而，包组织引起问题的频率，让切换到 Go 的开发人员吃惊。为什么 Go 包与其他语言如此不同？因为其不是 <code>分组(group)</code>，而是 <code>层次（layer）</code>。</p><h3 id="理解循环依赖"><a href="#理解循环依赖" class="headerlink" title="理解循环依赖"></a>理解循环依赖</h3><p>Go 的包与其他语言中的分组，主要区别在于 Go 不允许循环依赖。包 A 可以依赖于包 B，但是包 B 不能依赖于包 A。</p><p><img src="/images/packages-as-layers-not-groups-cn/5A25FB3F-B5FC-4A20-94D5-74BA54CF69DA.svg" alt="5A25FB3F-B5FC-4A20-94D5-74BA54CF69DA.svg"></p><p>对开发人员而言，当两个包共享公共代码，该限制会带来问题。通常有两种解决方案：将两个包合并成一个包，或者引入第三个包。</p><p><img src="/images/packages-as-layers-not-groups-cn/744E11AC-B068-430F-9827-54940085D941.svg" alt="744E11AC-B068-430F-9827-54940085D941.svg+xml"></p><p>然而，拆分成越来越多的包只是把问题推迟到未来。最终，仍会得到一大堆乱七八糟的包，缺少真正的结构。</p><h3 id="偷师标准库"><a href="#偷师标准库" class="headerlink" title="偷师标准库"></a>偷师标准库</h3><p>当你使用 Go 编程需要指引时，查看标准库是最有效的窍门之一。没有代码是完美的，但 Go 标准库封装了语言创造者的许多理念。</p><p>例如，<code>net/http</code> 包构建在 <code>net</code> 包的抽象之上，而 <code>net</code> 包又构建在 <code>io</code> 层的抽象之上。假设 <code>net</code> 包需要以某种方式依赖 <code>net/http</code> 是没有意义的，以上包结构行之有效。</p><p><img src="/images/packages-as-layers-not-groups-cn/2EAF705B-4584-4128-AF1B-B6CDD8E1181B.svg" alt="2EAF705B-4584-4128-AF1B-B6CDD8E1181B.svg+xml"></p><p>虽然在标准库中行之有效，但很难延续到应用程序开发。</p><h3 id="将层次应用于应用程序开发"><a href="#将层次应用于应用程序开发" class="headerlink" title="将层次应用于应用程序开发"></a>将层次应用于应用程序开发</h3><p>我们将看到一个名为 <a href="https://github.com/benbjohnson/wtf"><code>WTF Dial</code></a> 的示例应用程序，您可以阅读 <a href="https://www.gobeyond.dev/wtf-dial/">介绍性文章</a> 了解更多关于它的信息。</p><p>在此应用程序中，有两个逻辑层：</p><ol><li>SQLite 数据库</li><li>HTTP 服务</li></ol><p>我们为它们各创建一个包 —— <code>sqlite</code> &amp; <code>http</code> 。许多人拒绝将包命名成与标准库包相同的名称。这是一个站得住脚的说法，你也可以将其命名为 <code>wtfhttp</code>。然而，HTTP 包完全封装了 <code>net/HTTP</code> 包，因此在同一文件中不会同时使用两者。给每个包加前缀既乏味又难看，所以我没有这么做。</p><h4 id="原始的方法"><a href="#原始的方法" class="headerlink" title="原始的方法"></a>原始的方法</h4><p>一种构造应用程序的方法是将数据类型（如 <code>User</code>、<code>Dial</code>）和函数（如 <code>FindUser()</code>, <code>CreateDial()</code> ）放到 <code>sqlite</code> 中。<code>http</code> 包可以直接依赖它：</p><p><img src="/images/packages-as-layers-not-groups-cn/1BBCD044-BC5D-4449-A13B-ABF05AA79576.svg" alt="1BBCD044-BC5D-4449-A13B-ABF05AA79576.svg+xml"></p><p>这是一个不错的方法，它适用于简单的应用程序。不过，最终会遇到一些问题。</p><p>首先，我们的数据类型被命名为 <code>sqlite.User</code> 以及 <code>sqlite.Dial</code>。两个数据类型属于我们的应用程序，而不是 <code>SQLite</code>，如此命名很奇怪。</p><p>第二，HTTP 层现在只能提供来自 SQLite 的数据。如果需要在中间添加一个缓存层，会发生什么？或者如何支持其他类型的数据存储，比如 Postgres，或者甚至存储为JSON到磁盘上？</p><p>最后，需要为每次 HTTP 测试运行一个 SQLite 数据库，因为没有抽象层来 mock 它。我通常支持尽可能多地进行端到端测试，但是一些用例适合在较高层次引入单元测试。一旦引入了云服务，你不希望在每次测试调用都运行它的情况下，尤其正确。</p><h4 id="隔离您的业务领域"><a href="#隔离您的业务领域" class="headerlink" title="隔离您的业务领域"></a>隔离您的业务领域</h4><p>第一点可以改变的是，将 <em>业务领域</em> 移动到自己的包中。也可以称之为“应用领域”。它是特定于应用程序的数据类型 —— 例如，<code>User</code>, <code>Dial</code>（在 WTF Dial 的例子中）。</p><p>为此，我使用根包（<code>wtf</code>）实现该意图，因为它已经很简便地以应用程序命名，而且根包是新开发人员打开代码库时首先看到的地方。类型现在更好的命名为 <code>wtf.User</code> 以及 <code>wtf.Dial</code>。</p><p><img src="/images/packages-as-layers-not-groups-cn/804113F0-9C8B-4363-BC04-8E9113A84CA7.svg" alt="804113F0-9C8B-4363-BC04-8E9113A84CA7.svg+xml"></p><p>可以看到 <code>wtf.Dial</code> 类型的一个示例：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Dial <span class="hljs-keyword">struct</span> &#123;ID <span class="hljs-keyword">int</span> <span class="hljs-string">`json:&quot;id&quot;`</span><span class="hljs-comment">// Owner of the dial. Only the owner may delete the dial.</span>UserID <span class="hljs-keyword">int</span>   <span class="hljs-string">`json:&quot;userID&quot;`</span>User   *User <span class="hljs-string">`json:&quot;user&quot;`</span><span class="hljs-comment">// Human-readable name of the dial.</span>Name <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><span class="hljs-comment">// Code used to share the dial with other users.</span><span class="hljs-comment">// It allows the creation of a shareable link without</span><span class="hljs-comment">// explicitly inviting users.</span>InviteCode <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;inviteCode,omitempty&quot;`</span><span class="hljs-comment">// Aggregate WTF level for the dial.</span>Value <span class="hljs-keyword">int</span> <span class="hljs-string">`json:&quot;value&quot;`</span><span class="hljs-comment">// Timestamps for dial creation &amp; last update.</span>CreatedAt time.Time <span class="hljs-string">`json:&quot;createdAt&quot;`</span>UpdatedAt time.Time <span class="hljs-string">`json:&quot;updatedAt&quot;`</span><span class="hljs-comment">// List of associated members and their contributing WTF level.</span><span class="hljs-comment">// This is only set when returning a single dial.</span>Memberships []*DialMembership <span class="hljs-string">`json:&quot;memberships,omitempty&quot;`</span>&#125;</code></pre><p>以上代码没有引用任何实现细节，只有基本类型和 <code>time.Time</code>。添加 JSON 标记是为了方便。</p><h4 id="通过抽象去除依赖"><a href="#通过抽象去除依赖" class="headerlink" title="通过抽象去除依赖"></a>通过抽象去除依赖</h4><p>应用程序结构看起来好些了，但是 HTTP 依赖于 SQLite 仍然很奇怪。 HTTP 服务想要从底层数据存储中获取数据，它并不特别关心底层数据存储是否是 SQLite。</p><p>为了解决该问题，我们为业务域中的服务操作创建接口。服务通常是Create/Read/Update/Delete（CRUD），但可以扩展到其他操作。</p><pre><code class="hljs go"><span class="hljs-comment">// DialService represents a service for managing dials.</span><span class="hljs-keyword">type</span> DialService <span class="hljs-keyword">interface</span> &#123;<span class="hljs-comment">// Retrieves a single dial by ID along with associated memberships. Only</span><span class="hljs-comment">// the dial owner &amp; members can see a dial. Returns ENOTFOUND if dial does</span><span class="hljs-comment">// not exist or user does not have permission to view it.</span>FindDialByID(ctx context.Context, id <span class="hljs-keyword">int</span>) (*Dial, error)<span class="hljs-comment">// Retrieves a list of dials based on a filter. Only returns dials that</span><span class="hljs-comment">// the user owns or is a member of. Also returns a count of total matching</span><span class="hljs-comment">// dials which may different from the number of returned dials if the</span><span class="hljs-comment">// &quot;Limit&quot; field is set.</span>FindDials(ctx context.Context, filter DialFilter) ([]*Dial, <span class="hljs-keyword">int</span>, error)<span class="hljs-comment">// Creates a new dial and assigns the current user as the owner.</span><span class="hljs-comment">// The owner will automatically be added as a member of the new dial.</span>CreateDial(ctx context.Context, dial *Dial) error<span class="hljs-comment">// Updates an existing dial by ID. Only the dial owner can update a dial.</span><span class="hljs-comment">// Returns the new dial state even if there was an error during update.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Returns ENOTFOUND if dial does not exist. Returns EUNAUTHORIZED if user</span><span class="hljs-comment">// is not the dial owner.</span>UpdateDial(ctx context.Context, id <span class="hljs-keyword">int</span>, upd DialUpdate) (*Dial, error)<span class="hljs-comment">// Permanently removes a dial by ID. Only the dial owner may delete a dial.</span><span class="hljs-comment">// Returns ENOTFOUND if dial does not exist. Returns EUNAUTHORIZED if user</span><span class="hljs-comment">// is not the dial owner.</span>DeleteDial(ctx context.Context, id <span class="hljs-keyword">int</span>) error&#125;</code></pre><p>现在，领域包（<code>wtf</code>）不仅指定了数据结构，还指定了层次之间如何通信的接口约定。使包层次结构扁平化，所有包现在都依赖于领域包。使得我们能够打破包之间的直接依赖关系，而且能够引入诸如 <code>mock</code> 包之类的替代实现。</p><p><img src="/images/packages-as-layers-not-groups-cn/E1B5DA68-F665-4427-A355-9CF8A7DB32A4.svg" alt="E1B5DA68-F665-4427-A355-9CF8A7DB32A4.svg+xml"></p><h4 id="重新组包"><a href="#重新组包" class="headerlink" title="重新组包"></a>重新组包</h4><p>打破包之间的依赖关系可以让我们灵活地使用代码。对于二进制应用程序 <code>wtfd</code>，我们仍然希望 <code>http</code> 依赖于 <code>sqlite</code>（参见 <a href="https://github.com/benbjohnson/wtf/blob/main/cmd/wtfd/main.go#L180-L205">wtf/main.go</a> )，但是对于测试，我们可以将 <code>http</code> 更改为依赖于新的<code>mock</code> 包（参见<a href="https://github.com/benbjohnson/wtf/blob/main/http/server_test.go#L22-L59">http/server_test.go</a>):</p><p><img src="/images/packages-as-layers-not-groups-cn/38EFCB27-8A0D-4DE8-86CA-BAD89EAF1030.svg" alt="38EFCB27-8A0D-4DE8-86CA-BAD89EAF1030.svg+xml"></p><p>对我们的小型 web 应用程序 WTF Dial 而言，这可能过于炫技了，但随着代码库的增长，会变得越来越重要。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>包是 Go 中一个强大的工具，但是如果你把它看作分组而不是层次的话，它会让你感到无尽的沮丧，理解应用程序的逻辑层之后，可以提取业务域的数据类型和接口约定，并将它们移动到根包，作为所有子包的通用域语言。随着时间的推移，定义领域语言对于应用程序的增长至关重要。</p><p>有问题或意见，请在 <a href="https://github.com/benbjohnson/wtf/discussions">WTF Dial GitHub 讨论板</a> 上创建新帖。</p><p><em>原文：</em><a href="https://www.gobeyond.dev/packages-as-layers/">https://www.gobeyond.dev/packages-as-layers/</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/03-03-2021/packages-as-layers-not-groups-cn.html">https://www.cyningsun.com/03-03-2021/packages-as-layers-not-groups-cn.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;四年前，我写了一篇名为 &lt;a href=&quot;https://www.gobeyond.dev/standard-package-layout/&quot;&gt;《标准包布局》&lt;/a&gt; 的文章试图阐述：包布局。即使对高级 Go 开发人员来说，这也是最困难的话题之一。然而，大多数开发人员还在艰
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Package" scheme="https://www.cyningsun.com/tag/Package/"/>
    
  </entry>
  
  <entry>
    <title>缓存(4) —— 结构化缓存</title>
    <link href="https://www.cyningsun.com/02-18-2021/high-concurrency-cache-design.html"/>
    <id>https://www.cyningsun.com/02-18-2021/high-concurrency-cache-design.html</id>
    <published>2021-02-17T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.287Z</updated>
    
    <content type="html"><![CDATA[<p>在众多应用中，缓存都是标配，使用缓存都能获得非常巨大的性能提升。然而却少有人能把缓存用好，使用缓存的服务，随着需求的迭代都会不可避免的陷入一种怪圈：<br><strong>业务侧</strong></p><blockquote><ol><li>为了优化接口性能增加缓存</li><li>同一接口复杂度高、性能差、缺少可维护性，无法开发新需求   </li></ol></blockquote><p><strong>运维侧</strong></p><blockquote><ol><li>提高存储和查询容量应对使用压力</li><li>成本压力倒逼业务再次优化，提高缓存使用率</li></ol></blockquote><p>在反复的折腾之下，系统难以维护，最终不得不走向整体“重构”。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>以微博为例，当打开微博时，页面主要数据构成有：分类列表（左侧）；微博列表（中间）；个人信息；关注、粉丝、微博数（最右侧）。<br><img src="/images/high-concurrency-cache-design/weibo.png" alt="weibo.png"></p><p>按照一般的后台设计准则，假设页面所需的数据拆解如下：<br><img src="/images/high-concurrency-cache-design/structure.png" alt="structure.png"></p><p>需要重点说明几点：</p><ol><li>微博不等于微博正文<blockquote><p>微博指微博ID，微博正文指微博的内容。</p></blockquote></li><li>微博列表也是一种数据<blockquote><p>微博列表代表的是微博ID的集合</p></blockquote></li></ol><p>在<a href="/07-27-2020/how-to-write-rpc-interface.html#%E8%AE%A4%E8%AF%86%E8%B5%84%E6%BA%90">《如何设计RPC接口》</a> 中我们提到过一个观点：所有的数据都等于 ID + Content，同时 ID 又可以以集合的形式存在。</p><p>假设查询微博列表是一个单独的API接口，各种数据在系统中的表达分别为：post（微博）、profile（个人信息）、stat（点赞、评论等计数、点赞）。那么通常的实现是：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FROM</span> post <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> profile <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> stat ...</code></pre><p>两张大表直接进行关联。如果扛不住，就添加缓存，将查询结果缓存。</p><p>那么，在开发过程中是否真的无法逃出这一怪圈？答案当然是否定的，本文的目的就是承接 <a href="/12-15-2020/system-design-concept-and-relation.html">《系统设计之概念与关系》</a>、<a href="/07-27-2020/how-to-write-rpc-interface.html#%E8%AE%A4%E8%AF%86%E8%B5%84%E6%BA%90">《如何设计RPC接口》</a> ，谈谈如何设计，才能让数据落地到缓存。</p><h3 id="结构化缓存"><a href="#结构化缓存" class="headerlink" title="结构化缓存"></a>结构化缓存</h3><p>具体来看怎么做的，实际上可以将以上查询进行拆分：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> post <span class="hljs-keyword">WHERE</span> ...<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> profile <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">in</span> (...)<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stat <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">in</span> (...)</code></pre><p>很多人看到这里会直摇头，这不就直接会导致一次API调用，会直接导致 N 次数据库查询。那你怎么能这样拆分呢？</p><p>事实上并非如此，由于缓存的存在，后两个数据库查询都会命中应用缓存，最终只会有一次简单查询到数据库。考虑最差的情况应用缓存没有命中，后两个数据库查询也会极大概率命中数据的缓存。同时，随着业务的迭代，可以放心使用组合模式，不断组合其他数据，而不用担心复杂度的高度。再次，考虑 KOL 的微博访问量大，可以沿着结构树不断向上添加缓存（例如：在微博列表层添加缓存）。最后，如果分布式缓存压力太大，还可以组合本地缓存使用。</p><p>最重要的是，所有以上提到的所有优化点，都可以使用组合模式实现，而不用大幅度调整代码，避免陷入开发、优化、重构的怪圈。</p><p>再看拆分前，由于使用SQL关联操作，会在业务的发展过程中不断面临挑战：</p><ol><li>关联查询可能导致大范围的扫表，频繁磁盘IO，性能差</li><li>缓存命中率低</li><li>业务迭代，额外查询其他数据，复杂度不断叠加</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本文末尾，再次总结提及的几个关键观点：</p><ol><li>数据查询有且仅有三种模式<blockquote><ol><li>根据条件，分页查询 ID 列表</li><li>根据 ID 查询内容</li><li>根据 ID 列表批量查询内容</li></ol></blockquote></li><li>所有的结构仅仅存在两种关系<blockquote><ol><li>并列（兄弟）关系</li><li>父子关系</li></ol></blockquote></li><li>结构化和组合模式是应对复杂性有效方法<blockquote><p>缓存不过是一种形式的复杂性</p></blockquote></li></ol><p>当然此种实现并非没有代价。显然，如果数据的访问频率很低，极少的结果才会命中缓存，那么效果就微乎其微。而梳理数据关系、结构，以及按照拆分的形式实现代码，将花费不少的时间，在讲究快速开发、先撑住再优化的今天，很容易让开发者采取非此即彼的决策。</p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/02-18-2021/high-concurrency-cache-design.html">https://www.cyningsun.com/02-18-2021/high-concurrency-cache-design.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在众多应用中，缓存都是标配，使用缓存都能获得非常巨大的性能提升。然而却少有人能把缓存用好，使用缓存的服务，随着需求的迭代都会不可避免的陷入一种怪圈：&lt;br&gt;&lt;strong&gt;业务侧&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;为了优化接口性能增加缓存
      
    
    </summary>
    
    
      <category term="缓存" scheme="https://www.cyningsun.com/category/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="结构化" scheme="https://www.cyningsun.com/tag/%E7%BB%93%E6%9E%84%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>永远不要在不知道如何停止的情况下启动一个 goroutine</title>
    <link href="https://www.cyningsun.com/01-31-2021/go-concurrency-goroutine-exit.html"/>
    <id>https://www.cyningsun.com/01-31-2021/go-concurrency-goroutine-exit.html</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2022-05-09T11:08:55.287Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在 Go 中，<code>goroutine</code> 的创建成本低，调度效率高，同时存在数十万个 <code>goroutine</code> 并不奇怪。虽然单个 <code>goroutine</code> 使用的内存有限，但是不意味着可以毫无限制的创建 <code>goroutine</code>。</p><blockquote><p>Never start a goroutine without knowing how it will stop</p></blockquote><p>每次启动 <code>goroutine</code> 时，必须知道 <code>goroutine</code> 何时、如何退出。否则，程序就潜藏着内存泄漏问题。在讨论协程退出前，先了解下协程为何阻塞</p><h3 id="协程阻塞"><a href="#协程阻塞" class="headerlink" title="协程阻塞"></a>协程阻塞</h3><p>协程阻塞无法自由退出，主要因为以下两点：</p><ul><li>超时控制</li><li>流程控制</li></ul><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>前者，很容易理解。一般来说启动 <code>goroutine</code> 处理事务，对于事务的处理完成时间都有一定的预期 举例：</p><blockquote><ul><li>RPC调用：最大超时时间不会超过用户的等待时间</li><li>定时任务：执行一次的时间不应该超过启动的间隔</li></ul></blockquote><p>针对何时退出，Go 中 提供了 <code>Context</code> 用于 <code>goroutine</code> 生命周期管理</p><blockquote><ul><li>Cancellation via context.WithCancel.</li><li>Timeout via context.WithDeadline.<pre><code class="hljs go">req, err := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://play.golang.org/&quot;</span>, <span class="hljs-literal">nil</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)&#125;ctx, cancel := context.WithTimeout(req.Context(), <span class="hljs-number">1</span>*time.Second)<span class="hljs-keyword">defer</span> cancel()req = req.WithContext(ctx)client := http.DefaultClientresp, err := client.Do(req)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)&#125;fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, resp.StatusCode)</code></pre></li></ul></blockquote><h4 id="channel-amp-select"><a href="#channel-amp-select" class="headerlink" title="channel &amp; select"></a>channel &amp; select</h4><p>后者，相对来说比较难理解一些。尤其是其他语言的使用者，对于他们而言，程序中的流程控制一般意味着：</p><blockquote><ul><li>if/else</li><li>for loop</li></ul></blockquote><p>在 Go 中，类似的理解仅仅对了一小半。因为 <strong>channel 和 select 才是流程控制的重点</strong>。</p><p>channel 提供了强大能力，帮助数据从一个 goroutine 流转到另一个 goroutine。也意味着，channel 对程序的 <code>数据流</code> 和 <code>控制流</code> 同时存在影响。</p><blockquote><ul><li>closed 的 channel 永远不会阻塞<pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>, <span class="hljs-number">2</span>)    ch &lt;- <span class="hljs-literal">true</span>    ch &lt;- <span class="hljs-literal">true</span>    <span class="hljs-built_in">close</span>(ch)    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;        fmt.Println(v) <span class="hljs-comment">// called twice</span>    &#125;&#125;</code></pre></li><li>nil 的 channel 总是阻塞<pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>    ch &lt;- <span class="hljs-literal">true</span> <span class="hljs-comment">// blocks forever</span>&#125;</code></pre></li><li>buffered/unbuffered channel 介于两者之间，会因为 channel 是否可以读写阻塞</li></ul></blockquote><p>那么究竟如何判断 channel 能否读写呢？答案就是 select。</p><pre><code class="hljs go"><span class="hljs-keyword">select</span>&#123;<span class="hljs-keyword">case</span> channel_send_or_receive:    <span class="hljs-comment">//Dosomething</span><span class="hljs-keyword">case</span> channel_send_or_receive:    <span class="hljs-comment">//Dosomething</span><span class="hljs-keyword">default</span>:    <span class="hljs-comment">//Dosomething</span>&#125;</code></pre><h3 id="协程退出"><a href="#协程退出" class="headerlink" title="协程退出"></a>协程退出</h3><p>说了这么多，协程怎么退出呢？相信通过以上部分很容易得到结论：</p><ul><li>超时返回</li><li>根据 channel 可读状态返回</li></ul><blockquote><pre><code class="hljs go"> <span class="hljs-comment">// 方式一：遍历关闭的 channel</span><span class="hljs-keyword">for</span> x := <span class="hljs-keyword">range</span> closedCh &#123;    fmt.Printf(<span class="hljs-string">&quot;Process %d\n&quot;</span>, x)&#125;<span class="hljs-comment">// 方式二：Select 可读 channel</span><span class="hljs-keyword">for</span> &#123;    <span class="hljs-keyword">select</span> &#123;        <span class="hljs-keyword">case</span> &lt;-stopCh:            fmt.Println(<span class="hljs-string">&quot;Recv stop signal&quot;</span>)            <span class="hljs-keyword">return</span>         <span class="hljs-keyword">case</span> &lt;-t.C:            fmt.Println(<span class="hljs-string">&quot;Working .&quot;</span>)    &#125;&#125;</code></pre></blockquote><h3 id="完美退出"><a href="#完美退出" class="headerlink" title="完美退出"></a>完美退出</h3><p>协程能够退出就够了么？还不够，完美的退出应该包含以下三点：</p><ul><li>通知协程退出</li><li>通知确认，协程退出</li><li>获取协程最终返回的错误</li></ul><blockquote><p>举个例子：errgroup</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span> <span class="hljs-title">Wait</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;    g.wg.Wait()    <span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> &#123;        g.cancel()    &#125;    <span class="hljs-keyword">return</span> g.err&#125;</code></pre></blockquote><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/01-31-2021/go-concurrency-goroutine-exit.html">https://www.cyningsun.com/01-31-2021/go-concurrency-goroutine-exit.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在 Go 中，&lt;code&gt;goroutine&lt;/code&gt; 的创建成本低，调度效率高，同时存在数十万个 &lt;code&gt;goroutine&lt;/c
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Concurrency" scheme="https://www.cyningsun.com/tag/Concurrency/"/>
    
  </entry>
  
</feed>
